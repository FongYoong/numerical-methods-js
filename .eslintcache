[{"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\constants\\categories.js":"1","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js":"2","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js":"3","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js":"4","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js":"5","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js":"6","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js":"7","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js":"8","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\System.js":"9","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js":"10","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js":"11","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js":"12","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js":"13","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js":"14","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js":"15","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js":"16","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js":"17","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js":"18","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js":"19","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js":"20","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js":"21","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js":"22","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js":"23","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js":"24","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js":"25","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\index.js":"26","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\NotFound.js":"27","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js":"28","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js":"29","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\matrix_utils.js":"30","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\App.js":"31","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js":"32","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js":"33","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js":"34","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\MethodInfo.js":"35","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js":"36","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\Graph.js":"37","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\MethodType.js":"38","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js":"39","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\ErrorBoundary.js":"40","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\header\\Header.js":"41","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\utils.js":"42","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Menu.js":"43"},{"size":14393,"mtime":1615043494070,"results":"44","hashOfConfig":"45"},{"size":21660,"mtime":1614933013752,"results":"46","hashOfConfig":"45"},{"size":25357,"mtime":1614933040174,"results":"47","hashOfConfig":"45"},{"size":23144,"mtime":1614933058737,"results":"48","hashOfConfig":"45"},{"size":13746,"mtime":1614933077036,"results":"49","hashOfConfig":"45"},{"size":23979,"mtime":1614874703885,"results":"50","hashOfConfig":"45"},{"size":26800,"mtime":1615035491065,"results":"51","hashOfConfig":"45"},{"size":3899,"mtime":1614855713251,"results":"52","hashOfConfig":"45"},{"size":34924,"mtime":1615039671244,"results":"53","hashOfConfig":"45"},{"size":22760,"mtime":1614935998791,"results":"54","hashOfConfig":"45"},{"size":18152,"mtime":1615038802538,"results":"55","hashOfConfig":"45"},{"size":17319,"mtime":1615035205821,"results":"56","hashOfConfig":"45"},{"size":19375,"mtime":1615035238692,"results":"57","hashOfConfig":"45"},{"size":16836,"mtime":1615035257328,"results":"58","hashOfConfig":"45"},{"size":18665,"mtime":1615035265257,"results":"59","hashOfConfig":"45"},{"size":17374,"mtime":1615035272995,"results":"60","hashOfConfig":"45"},{"size":19828,"mtime":1614925428075,"results":"61","hashOfConfig":"45"},{"size":35451,"mtime":1614925307432,"results":"62","hashOfConfig":"45"},{"size":18337,"mtime":1614932254732,"results":"63","hashOfConfig":"45"},{"size":25440,"mtime":1615039098805,"results":"64","hashOfConfig":"45"},{"size":22019,"mtime":1615038969107,"results":"65","hashOfConfig":"45"},{"size":23041,"mtime":1615041218320,"results":"66","hashOfConfig":"45"},{"size":20676,"mtime":1615039130303,"results":"67","hashOfConfig":"45"},{"size":32320,"mtime":1615039184253,"results":"68","hashOfConfig":"45"},{"size":23065,"mtime":1615041178860,"results":"69","hashOfConfig":"45"},{"size":1020,"mtime":1614579888854,"results":"70","hashOfConfig":"45"},{"size":1927,"mtime":1615038744695,"results":"71","hashOfConfig":"45"},{"size":17704,"mtime":1614911809493,"results":"72","hashOfConfig":"45"},{"size":16668,"mtime":1614929500823,"results":"73","hashOfConfig":"45"},{"size":17495,"mtime":1614849591149,"results":"74","hashOfConfig":"45"},{"size":1592,"mtime":1615038467785,"results":"75","hashOfConfig":"45"},{"size":3927,"mtime":1615037069202,"results":"76","hashOfConfig":"45"},{"size":17129,"mtime":1614932701090,"results":"77","hashOfConfig":"45"},{"size":16376,"mtime":1614875949534,"results":"78","hashOfConfig":"45"},{"size":1278,"mtime":1614911098191,"results":"79","hashOfConfig":"45"},{"size":23709,"mtime":1614925284530,"results":"80","hashOfConfig":"45"},{"size":5367,"mtime":1614673874691,"results":"81","hashOfConfig":"45"},{"size":1642,"mtime":1615093990239,"results":"82","hashOfConfig":"45"},{"size":23686,"mtime":1615035178563,"results":"83","hashOfConfig":"45"},{"size":2419,"mtime":1615038541348,"results":"84","hashOfConfig":"45"},{"size":10288,"mtime":1615097174143,"results":"85","hashOfConfig":"45"},{"size":1896,"mtime":1614851748722,"results":"86","hashOfConfig":"45"},{"size":2441,"mtime":1615084773741,"results":"87","hashOfConfig":"45"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1mhuixq",{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"95"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"101"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"110"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"92"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"95"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"101"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"122","messages":"123","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124","usedDeprecatedRules":"92"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"127","messages":"128","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"129","usedDeprecatedRules":"92"},{"filePath":"130","messages":"131","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"132","messages":"133","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"134"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"137","usedDeprecatedRules":"92"},{"filePath":"138","messages":"139","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"140","usedDeprecatedRules":"110"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"143","messages":"144","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"145","messages":"146","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"147","usedDeprecatedRules":"101"},{"filePath":"148","messages":"149","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"150","usedDeprecatedRules":"110"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"153","usedDeprecatedRules":"92"},{"filePath":"154","messages":"155","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"158"},{"filePath":"159","messages":"160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},{"filePath":"161","messages":"162","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"163","usedDeprecatedRules":"95"},{"filePath":"164","messages":"165","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"166","usedDeprecatedRules":"167"},{"filePath":"168","messages":"169","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"170","messages":"171","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"172","messages":"173","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"174","messages":"175","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},{"filePath":"176","messages":"177","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"178","usedDeprecatedRules":"110"},{"filePath":"179","messages":"180","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"181","messages":"182","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"183","messages":"184","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"185"},{"filePath":"186","messages":"187","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"188","messages":"189","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"190","messages":"191","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"192","messages":"193","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"194","messages":"195","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"196","messages":"197","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\constants\\categories.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js",[],["198","199"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js",[],["200","201"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js",[],["202","203"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js",[],["204","205"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js",["206"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearFalsePosition({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(0);\r\n    const [upperX, setUpperX] = useState(3);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be a number!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"Upper x must be a number!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0005);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    let results = [];\r\n    let iterations = 1;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let i = 0;\r\n        while (true) {\r\n            let oldLowerX = (i === 0) ? lowerX: results[i - 1].newLowerX;\r\n            let oldUpperX = (i === 0) ? upperX: results[i - 1].newUpperX;\r\n            let newLowerX = oldLowerX;\r\n            let newUpperX = oldUpperX;\r\n            let lowerFuncResult, upperFuncResult, rootX, rootFuncResult, errorX;\r\n            try {\r\n                lowerFuncResult = functionValue.evaluate({x : oldLowerX});\r\n                upperFuncResult = functionValue.evaluate({x : oldUpperX}); // upperFuncResult is for visualisation purposes, no relevance in the calculations\r\n                rootX = oldUpperX - upperFuncResult * (oldLowerX - oldUpperX) / (lowerFuncResult - upperFuncResult);\r\n                rootFuncResult = functionValue.evaluate({x : rootX});\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            let rootFound = false;\r\n            let product = lowerFuncResult * rootFuncResult;\r\n            if (product < 0) {\r\n                newUpperX = rootX;\r\n            }\r\n            else if (product > 0) {\r\n                newLowerX = rootX;\r\n            }\r\n            else {\r\n                rootFound = true;\r\n            }\r\n\r\n            if (!rootFound && i !== 0) {\r\n                // Check if root error is lower than threshold\r\n                errorX = Math.abs(rootX - results[i - 1].rootX);\r\n                if (errorX < errorThreshold){\r\n                    rootFound = true;\r\n                }\r\n            }\r\n            results.push({\r\n                oldLowerX,\r\n                newLowerX,\r\n                oldUpperX,\r\n                newUpperX,\r\n                rootX,\r\n                lowerFuncResult,\r\n                upperFuncResult,\r\n                rootFuncResult,\r\n                errorX,\r\n            });\r\n            i++;\r\n            if (rootFound) {\r\n                break;\r\n            }\r\n            if (i > 1000) {\r\n                exceedIterError = true;\r\n                exceedIterErrorText = \"Exceeded 1000 iterations!\";\r\n                break;\r\n            }\r\n        }\r\n        iterations = i;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown}/>\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, f(x):\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Lower x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setLowerX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={lowerX.toString()}\r\n                                        helperText={lowerXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Upper x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setUpperX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={upperX.toString()}\r\n                                        helperText={upperXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"errorThreshold-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Error threshold:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setErrorThreshold(parseFloat(event.target.value))}\r\n                                        error={thresholdError}\r\n                                        label={thresholdError?\"Error\":\"\"}\r\n                                        defaultValue={errorThreshold.toString()}\r\n                                        helperText={thresholdErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n            \r\n        </>\r\n    );\r\n}\r\n/*\r\nimport Snackbar from '@material-ui/core/Snackbar';\r\nconst [openErrorSnackbar, setOpenErrorSnackbar] = useState(false);\r\nconst errorSnackbarClose = (event, reason) => {\r\n    if (reason === 'clickaway') {\r\n        return;\r\n    }\r\n    setOpenErrorSnackbar(false);\r\n};\r\n<Snackbar open={openErrorSnackbar} autoHideDuration={2000} onClose={errorSnackbarClose}>\r\n    <Alert onClose={errorSnackbarClose} severity=\"error\">\r\n        There is an error with the {functionError?\"function\":\"iterations\"}.\r\n    </Alert>\r\n</Snackbar>\r\n*/\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let oldLowerXLatex = String.raw`x_{lower_{${currentIteration - 1}}}`;\r\n        let oldUpperXLatex = String.raw`x_{upper_{${currentIteration - 1}}}`;\r\n        let newLowerXLatex = String.raw`x_{lower_{${currentIteration}}}`;\r\n        let newUpperXLatex = String.raw`x_{upper_{${currentIteration}}}`;\r\n        let newRootXLatex = String.raw`x_{root_{${currentIteration - 1}}}`;\r\n        latexContent=String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${oldLowerXLatex} &=& ${formatLatex(currentResult.oldLowerX)}\r\n        \\\\ ${oldUpperXLatex} &=& ${formatLatex(currentResult.oldUpperX)}\r\n        \\\\ ${newRootXLatex} &=&  ${oldUpperXLatex}-\\frac{f(${oldUpperXLatex})(${oldLowerXLatex} - ${oldUpperXLatex})}{f(${oldLowerXLatex}) - f(${oldUpperXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.rootX)}\r\n        \\\\\r\n        `;\r\n\r\n        let rootFound = false;\r\n        latexContent += String.raw`\r\n        \\\\ f(${oldLowerXLatex}) &=& ${formatLatex(currentResult.lowerFuncResult)}\r\n        \\\\ f(${newRootXLatex}) &=& ${formatLatex(currentResult.rootFuncResult)}\r\n        \\\\\r\n        \\\\\r\n        `;\r\n        let product = currentResult.lowerFuncResult * currentResult.rootFuncResult;\r\n        if (product < 0) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) < 0,\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${oldLowerXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${newRootXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else if (product > 0) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) > 0,\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${newRootXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${oldUpperXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else {\r\n            rootFound = true;\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Root found because }\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ f(${oldLowerXLatex})f(${newRootXLatex}) == 0.\r\n            `;\r\n        }\r\n        \r\n        if (!rootFound && currentIteration > 1) {\r\n            let oldRootXLatex = String.raw`x_{root_{${currentIteration - 2}}}`;\r\n            latexContent += String.raw`\r\n            \\\\ ${oldRootXLatex} &=& ${formatLatex(results[currentIteration - 2].rootX)}\r\n            \\\\ Error &=& |${newRootXLatex} - ${oldRootXLatex}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n            \\\\\r\n            `;\r\n            if (currentResult.errorX < params.errorThreshold) {\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Root found because:}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ Error &<& Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorX)} &<& ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex});\r\n            calculator.current.setExpression({ id: 'lowerX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Lower\", showLabel:true, latex:\r\n                `(${currentResult.oldLowerX}, ${currentResult.lowerFuncResult})` });\r\n            calculator.current.setExpression({ id: 'upperX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Upper\", showLabel:true, latex:\r\n                `(${currentResult.oldUpperX}, ${currentResult.upperFuncResult})` });\r\n            calculator.current.setExpression({ id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel:true, latex:\r\n                `(${currentResult.rootX}, 0)` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                \r\n                    <Grid container xs item direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                        <Grid xs item className=\"iteration-slider\">\r\n                            <Slide direction=\"left\" triggerOnce>\r\n                                <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                    <Slider\r\n                                        orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                        onChange={(event, value) => setCurrentIteration(value)}\r\n                                        defaultValue={1}\r\n                                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                                        step={1}\r\n                                        marks\r\n                                        min={1}\r\n                                        max={params.iterations}\r\n                                        valueLabelDisplay=\"on\"\r\n                                    />\r\n                                    \r\n                                </Box>\r\n                            </Slide>\r\n                        </Grid>\r\n                        <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"step-math\">\r\n                                <Zoom duration={500} triggerOnce>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                Iteration {currentIteration}:\r\n                                            </Typography>\r\n                                            <TeX math={latexContent} block />\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Zoom>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"graph-button\">\r\n                            <Slide direction=\"right\" triggerOnce>\r\n                                <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                            </Slide>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearFalsePosition;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js",["207","208"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js",["209"],"import React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport { Zoom } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport haroldImage from '../../../images/harold.jpg';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".main\",\r\n        title: \"Incomplete!\",\r\n        content:\r\n        \"Nothing to see here.\",\r\n        disableBeacon: true,\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(2)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n    harold: {\r\n        height: \"auto\",\r\n        width: \"30vw\",\r\n        \"border-radius\": \"3em\",\r\n        \"box-shadow\": \"0px 8px 6px rgba(34,34,34,0.6)\",\r\n    }\r\n}));\r\n\r\nfunction FFT({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n  \r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography className=\"main\" variant=\"body1\">\r\n                        Incomplete! Nothing to see here.\r\n                    </Typography>\r\n                    <Divider />\r\n                    <img className={styleClasses.harold} src={haroldImage} alt=\"Hide the Pain Harold\" />\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n            \r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default FFT;",["210","211"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\System.js",["212"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix20 as initialMatrix, createNewColumn, generateGridCallback, gridTo2DArray, cloneArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst ORDER_NAMES = ['x', 'y', 'u', 'v', 'w', 'z', 'p', 'q', 'r', 's', 't'];\r\nconst ORDER_FUNCTIONS = ['u', '-x u-y'];\r\nconst ORDER_FUNCTIONS_TEXT = ['u', '-x u-y'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order/Number of equations\",\r\n        content:\r\n        \"Specify the number of 1st order differential equations.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n        \"Choose either Euler or Runge-Kutta.\",\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Functions\",\r\n        content:\r\n        \"Type each function containing the relevant variables. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of each variable.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the selected method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeSystem({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Solver mode: Euler or Runge\r\n    const [solverType, setSolverType] = useState('runge');\r\n\r\n    // Order/ Number of equations\r\n    const [order, setOrder] = useState(2);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order < 2) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be 2 or higher.\";\r\n    }\r\n    else if (order > 9) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! A maximum of 9 is allowed for performance reasons.\";\r\n    }\r\n    const orderArray = [...Array(orderError ? 1 : order).keys()];\r\n    const validVariables = ORDER_NAMES.slice(0, order + 1);\r\n\r\n    // Functions\r\n    const [functionLatexs, setFunctionLatexs] = useState(ORDER_FUNCTIONS.slice());\r\n    const [functionTexts, setFunctionTexts] = useState(ORDER_FUNCTIONS_TEXT.slice());\r\n\r\n    const functionLatexsRef= useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef= useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = orderArray.slice().fill(false);\r\n    let functionErrorTexts = orderArray.slice().fill(\"\");\r\n\r\n    const testScope = validVariables.reduce((accumulated, v) => {\r\n        accumulated[v] = 0;\r\n        return accumulated;\r\n    }, {});\r\n    \r\n    for (let i = 0; i < order; i++){\r\n        if (orderError) {\r\n            break;\r\n        }\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (!validVariables.includes(node.name)) {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate(testScope);\r\n        }\r\n        catch(e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? `Only ${validVariables.join(',')} variables are allowed.` :  \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Initial values\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    let initialVector = { columns:[], rows:[{}] };\r\n\r\n    if (!orderError) {\r\n        const addVariableToVector = (variableName, variableValue) => {\r\n            const columns = initialVector.columns;\r\n            const rows = initialVector.rows;\r\n            columns.push(createNewColumn(columns.length, variableName));\r\n            let colName = `col_${columns.length}`;\r\n            rows[0][colName] = vectorState.rows[0].hasOwnProperty(colName) ?  vectorState.rows[0][colName] : variableValue;\r\n        }\r\n        for (let i = 0; i <= order; i++) {\r\n            if (i <= 9){\r\n                addVariableToVector(ORDER_NAMES[i], 0);\r\n            }\r\n        }\r\n        vectorState = initialVector;\r\n        initialVector = gridTo2DArray(vectorState.rows)[0];\r\n    }\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = !functionErrors.every((e) => e === false) || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = {x: [], y: []};\r\n    orderArray.forEach((i) => {\r\n        if (i !== 0) {\r\n            results[ORDER_NAMES[i + 1]] = [];\r\n        }\r\n    });\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results.x[iter - 1];\r\n            // Get current values\r\n            for (let k = 0; k < order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentValue = (iter === 0) ? initialVector[k + 1] : results[varName][iter - 1].newValue;\r\n                results[varName].push({\r\n                    currentValue,\r\n                });\r\n            }\r\n            // Find new values\r\n            if (solverType === 'runge') {\r\n                // k1\r\n                const originalScope = {x: currentX};\r\n                validVariables.filter((value, index) => index !== 0).forEach((value, index) => {\r\n                    originalScope[value] = results[value][iter].currentValue;\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k1 = functionNodes[k].evaluate(originalScope);\r\n                    results[varName][iter]['k1'] = k1;\r\n                }\r\n                // k2\r\n                const k2Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf * results[value][iter].k1;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k2 = functionNodes[k].evaluate(k2Scope);\r\n                    results[varName][iter]['k2'] = k2;\r\n                }\r\n                // k3\r\n                const k3Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf * results[value][iter].k2;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k3 = functionNodes[k].evaluate(k3Scope);\r\n                    results[varName][iter]['k3'] = k3;\r\n                }\r\n                // k4\r\n                const k4Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k4Scope[value] = k4Scope[value] + stepSize;\r\n                    }\r\n                    else {\r\n                        k4Scope[value] = k4Scope[value] + stepSize * results[value][iter].k3;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k4 = functionNodes[k].evaluate(k4Scope);\r\n                    results[varName][iter]['k4'] = k4;\r\n                }\r\n\r\n                // Find new values\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const newValue = currentValue + stepSize / 6 * (results[varName][iter]['k1']\r\n                                                                    + 2 * results[varName][iter]['k2']\r\n                                                                    + 2 * results[varName][iter]['k3']\r\n                                                                    + results[varName][iter]['k4']);\r\n                    results[varName][iter] = {...results[varName][iter], newValue};\r\n                }\r\n            }\r\n            else {\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const scope = {x: currentX, [varName]: currentValue};\r\n                    validVariables.filter((value, index) => index !== 0 && index !== k + 1 ).forEach((value, index) => {\r\n                        scope[value] = results[value][iter].currentValue;\r\n                    });\r\n                    const functionResult = functionNodes[k].evaluate(scope);\r\n                    const newValue = currentValue + stepSize * functionResult;\r\n                    results[varName][iter] = {...results[varName][iter], newValue, functionResult};\r\n                }\r\n            }\r\n            const newX = currentX + stepSize;\r\n            results.x.push(newX);\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatexs, solverType, order, validVariables, initialVector, stepSize, iterations, results, smallScreen};\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied to 1st order differential equations of the form &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        <br/>\r\n                        Up to 9 equations are supported, so even 9th order differential equation can be solved.\r\n                    </Typography>\r\n                    <Grid container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"order-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Order / Number of equations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setOrder(parseInt(event.target.value))}\r\n                                        error={orderError}\r\n                                        label={orderError?\"Error\":\"\"}\r\n                                        defaultValue={order.toString()}\r\n                                        helperText={orderErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Typography variant=\"h6\">\r\n                                Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                            </Typography>\r\n                            <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event)=>setSolverType(event.target.value)}>\r\n                                <FormControlLabel value=\"euler\" control={<Radio />} label=\"Euler\" />\r\n                                <FormControlLabel value=\"runge\" control={<Radio />} label=\"Runge-Kutta\" />\r\n                            </RadioGroup>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        {order < 10 && orderArray.map((i) =>\r\n                            <Grid key={\"function\" + i} xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={i===0 ? String.raw`y^{'}, \\frac{dy}{dx}` : String.raw`${ORDER_NAMES[i + 1]}^{'}, \\frac{d${ORDER_NAMES[i + 1]}}{dx}`} />\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={ORDER_FUNCTIONS[i]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(i, mathField.text());\r\n                                                setSpecificFunctionLatex(i, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[i]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[i]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        )}\r\n                    </Grid>\r\n\r\n                    <Grid className=\"initialVector-input\" container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        const results = params.results;\r\n        const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n        const newX = results.x[currentIteration - 1];\r\n\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(newX)}\r\n        \\end{array}\r\n        `;\r\n        if (params.solverType === 'runge') {\r\n            // k1\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{1${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k1)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k2\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{1${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{2${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k2)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k3\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{2${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{3${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k3)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k4\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{3${value}}`} (h)`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{4${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k4)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // Find new values\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1${varName}} + 2 k_{2${varName}} + 2 k_{3${varName}} + k_{4${varName}} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + h \\cdot ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult, currentIteration) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results['y'][i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${params.initialVector[0]}, ${r.currentValue})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${results.x[i]}, ${r.newValue})` });\r\n            }\r\n            const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n            const newX = results.x[currentIteration - 1];\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newValue})/(x-${newX})=${(currentResult.newValue - currentResult.currentValue)/(newX - currentX)} \\left\\{${currentX}<x<${newX}\\right\\} \\left\\{${currentResult.currentValue}<y<${currentResult.newValue}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentX}, ${currentResult.currentValue})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${newX}, ${currentResult.newValue})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params, results: params.results['y']}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeSystem;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js",["213"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".intervalThreshold-input\",\r\n        title: \"Interval Threshold\",\r\n        content:\r\n            \"Specify the minimum interval threshold\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OptiGoldenSearch({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3+6x-4x^2`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(-1);\r\n    const [upperX, setUpperX] = useState(2);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n    let lowerXError = false;\r\n    if (isNaN(lowerX)) {\r\n        lowerXError = true;\r\n        lowerXErrorText = \"Lower x must be a number!\";\r\n    }\r\n    let upperXError = false;\r\n    if (isNaN(upperX)) {\r\n        upperXError = true;\r\n        upperXErrorText = \"Upper x must be a number!\";\r\n    }\r\n\r\n    // Interval threshold\r\n    const [intervalThreshold, setIntervalThreshold] = useState(0.25);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(intervalThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    if (intervalThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || lowerXError || upperXError || thresholdError;\r\n\r\n    // Solve\r\n    const goldenRatio = (Math.sqrt(5) - 1) / 2;\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    let results = [];\r\n    let iterations = 1;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let i = 0;\r\n        while (true) {\r\n            let oldLowerX = (i === 0) ? lowerX: results[i - 1].newLowerX;\r\n            let oldUpperX = (i === 0) ? upperX: results[i - 1].newUpperX;\r\n            const d = goldenRatio * (oldUpperX - oldLowerX);\r\n            let aX = oldUpperX - d;\r\n            let bX = oldLowerX + d;\r\n            let newLowerX = aX;\r\n            let newUpperX = bX;\r\n            let lowerFuncResult, upperFuncResult;\r\n            try {\r\n                lowerFuncResult = functionValue.evaluate({x : aX});\r\n                upperFuncResult = functionValue.evaluate({x : bX});\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            if (lowerFuncResult > upperFuncResult) {\r\n                newLowerX = oldLowerX;\r\n            }\r\n            else if (lowerFuncResult < upperFuncResult) {\r\n                newUpperX = oldUpperX;\r\n            }\r\n            // Check if interval is lower than threshold\r\n            const interval = Math.abs(newUpperX - newLowerX);\r\n            \r\n            results.push({\r\n                oldLowerX,\r\n                newLowerX,\r\n                oldUpperX,\r\n                newUpperX,\r\n                d,\r\n                aX,\r\n                bX,\r\n                lowerFuncResult,\r\n                upperFuncResult,\r\n                interval,\r\n            });\r\n            i++;\r\n            if (i > 1000) {\r\n                exceedIterError = true;\r\n                exceedIterErrorText = \"Exceeded 1000 iterations!\";\r\n                break;\r\n            }\r\n            if (interval < intervalThreshold){\r\n                break;\r\n            }\r\n        }\r\n        iterations = i;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, intervalThreshold, goldenRatio, iterations, exceedIterError, exceedIterErrorText, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, f(x):\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Lower x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setLowerX(parseFloat(event.target.value))}\r\n                                        error={intervalError || lowerXError}\r\n                                        label={intervalError || lowerXError ?\"Error\":\"\"}\r\n                                        defaultValue={lowerX.toString()}\r\n                                        helperText={lowerXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Upper x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setUpperX(parseFloat(event.target.value))}\r\n                                        error={intervalError || upperXError}\r\n                                        label={intervalError || upperXError ?\"Error\":\"\"}\r\n                                        defaultValue={upperX.toString()}\r\n                                        helperText={upperXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"intervalThreshold-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Interval threshold:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIntervalThreshold(parseFloat(event.target.value))}\r\n                                        error={thresholdError}\r\n                                        label={thresholdError?\"Error\":\"\"}\r\n                                        defaultValue={intervalThreshold.toString()}\r\n                                        helperText={thresholdErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let oldLowerXLatex = String.raw`x_{lower_{${currentIteration - 1}}}`;\r\n        let oldUpperXLatex = String.raw`x_{upper_{${currentIteration - 1}}}`;\r\n        let newLowerXLatex = String.raw`x_{lower_{${currentIteration}}}`;\r\n        let newUpperXLatex = String.raw`x_{upper_{${currentIteration}}}`;\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${oldLowerXLatex} &=& ${formatLatex(currentResult.oldLowerX)}\r\n        \\\\ ${oldUpperXLatex} &=& ${formatLatex(currentResult.oldUpperX)}\r\n        \\\\\r\n        \\\\ d &=& R (${oldUpperXLatex} - ${oldLowerXLatex})\r\n        \\\\   &=& ${formatLatex(currentResult.d)}\r\n        \\\\\r\n        \\\\ x_a &=& ${oldUpperXLatex} - d\r\n        \\\\     &=& ${formatLatex(currentResult.aX)}\r\n        \\\\ x_b &=& ${oldLowerXLatex} + d\r\n        \\\\     &=& ${formatLatex(currentResult.bX)}\r\n        \\\\\r\n        \\\\ f(x_a) &=& ${formatLatex(currentResult.lowerFuncResult)}\r\n        \\\\ f(x_b) &=& ${formatLatex(currentResult.upperFuncResult)}\r\n        \\\\\r\n        \\\\\r\n        `;\r\n        if (currentResult.lowerFuncResult > currentResult.upperFuncResult) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) > f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${oldLowerXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& x_b\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else if (currentResult.lowerFuncResult < currentResult.upperFuncResult) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) < f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& x_a\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${oldUpperXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) = f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& x_a\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& x_b\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\text{Uncertainty Interval} &=& |${newUpperXLatex} - ${newLowerXLatex}|\r\n        \\\\                             &=& |${formatLatex(currentResult.interval)}|\r\n        `;\r\n        if (currentIteration === params.iterations) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Stop searching because:}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Uncertainty Interval} &<& \\text{Interval Threshold}\r\n            \\\\ ${formatLatex(currentResult.interval)} &<& ${formatLatex(params.intervalThreshold)}\r\n            `;\r\n        }\r\n        \r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex});\r\n            calculator.current.setExpression({ id: 'x_a', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"x_a\", showLabel:true, latex:\r\n                `(${currentResult.aX}, ${currentResult.lowerFuncResult})` });\r\n            calculator.current.setExpression({ id: 'x_b', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"x_b\", showLabel:true, latex:\r\n                `(${currentResult.bX}, ${currentResult.upperFuncResult})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                \r\n                    <Grid container xs item direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                        <Grid xs item className=\"iteration-slider\">\r\n                            <Slide direction=\"left\" triggerOnce>\r\n                                <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                    <Slider\r\n                                        orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                        onChangeCommitted={(event, value) => setCurrentIteration(value)}\r\n                                        defaultValue={1}\r\n                                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                                        step={1}\r\n                                        marks\r\n                                        min={1}\r\n                                        max={params.iterations}\r\n                                        valueLabelDisplay=\"on\"\r\n                                    />\r\n                                    \r\n                                </Box>\r\n                            </Slide>\r\n                        </Grid>\r\n                        <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"step-math\">\r\n                                <Zoom duration={500} triggerOnce>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                Iteration {currentIteration}:\r\n                                            </Typography>\r\n                                            <TeX math={latexContent} block />\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Zoom>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"graph-button\">\r\n                            <Slide direction=\"right\" triggerOnce>\r\n                                <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                            </Slide>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\nexport default OptiGoldenSearch;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js",["214","215"],"import {isValidMath, mathjsKeywords, mathjsToLatex, formatLatex} from \"../../utils\";\r\nimport {getBinomialCoefficient} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useMemo} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".x-input\",\r\n        title: \"X value\",\r\n        content:\r\n            \"Specify the value of x at which to evaluate.\",\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the differential order to evaluate.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction DiffFinite({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3x^5+2x^3-8`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({x : 0});\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // x values\r\n    const [xInput, setXInput] = useState(1.5);\r\n    let xInputError = false;\r\n    let xInputErrorText = \"\";\r\n    if (isNaN(xInput)) {\r\n        xInputError = true;\r\n        xInputErrorText = \"x value cannot be empty!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 14) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! Due to the factorial nature of the finite difference, the browser will lag or crash if it attempts to compute this.\";\r\n    }\r\n\r\n    // Step Size\r\n    const [stepSize, setStepSize] = useState(0.01);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize) || stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size cannot be negative or zero!\";\r\n    }\r\n\r\n    let hasError = functionError || xInputError || orderError || stepSizeError;\r\n\r\n    // Solve\r\n    let latexContent;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let derivValue = derivative(functionValue, 'x');\r\n        for (let i = 0; i < order - 1; i++) {\r\n            derivValue = derivative(derivValue, 'x');\r\n        }\r\n        const evaluateFunction = (forward, offset) => {\r\n            const step = offset * stepSize ;\r\n            return forward ? functionValue.evaluate({x : xInput + step}) : functionValue.evaluate({x : xInput - step});\r\n        }\r\n\r\n        const denominator = Math.pow(stepSize, order);\r\n        let forwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n        }\r\n        let backwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n        }\r\n        let centralDiff = 0;\r\n        if (order > 1) {\r\n            for (let i = 0; i <= order; i++) {\r\n                centralDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(true, order/2 - i) / denominator;\r\n            }\r\n        }\r\n        else {\r\n            // To adhere to lecturer's annoying convention\r\n            centralDiff = (evaluateFunction(true, 1) - evaluateFunction(false, 1)) / (2 * stepSize);\r\n        }\r\n\r\n        const correctDerivative = derivValue.evaluate({x : xInput});\r\n\r\n        const forwardError = Math.abs(correctDerivative - forwardDiff);\r\n        const backwardError = Math.abs(correctDerivative - backwardDiff);\r\n        const centralError = Math.abs(correctDerivative - centralDiff);\r\n        \r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f^{${order}}(x) &=& ${mathjsToLatex(derivValue)}\r\n        \\\\                 &=& ${formatLatex(correctDerivative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Forward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{${order}-i} \\dbinom{${order}}{i} f(x+ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            //forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, order - i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, i))}) ${i===order? '':'+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(forwardDiff)}\r\n        \\end{array}\r\n        `;\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Backward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x-ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            // backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(false, i))}) ${i===order? '':'+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(backwardDiff)}\r\n        \\end{array}\r\n        `;\r\n\r\n        if (order === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{2h} [f(x+h) - f(x-h)]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(2*stepSize)}} [${formatLatex(evaluateFunction(true, 1))} - ${formatLatex(evaluateFunction(false, 1))} ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{h^{${order}}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x+(\\frac{n}{2}-i)h) \\right]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(stepSize)}^{${order}}} [\r\n            `;\r\n            for (let i = 0; i <= order; i++) {\r\n                latexContent += String.raw`\r\n                (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, order/2 - i))}) ${i===order? '':'+'}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Percentage Error} &=& |Actual - Estimate|\r\n        \\\\\r\n        \\\\ E_{Forward} &=& ${formatLatex(forwardError)}\r\n        \\\\ E_{Backward} &=& ${formatLatex(backwardError)}\r\n        \\\\ E_{Central} &=& ${formatLatex(centralError)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                    \r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"x-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        x:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setXInput(parseFloat(event.target.value))}\r\n                                        error={xInputError}\r\n                                        label={xInputError?\"Error\":\"\"}\r\n                                        defaultValue={xInput.toString()}\r\n                                        helperText={xInputErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"order-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Order:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setOrder(parseInt(event.target.value))}\r\n                                        error={orderError}\r\n                                        label={orderError?\"Error\":\"\"}\r\n                                        defaultValue={order.toString()}\r\n                                        helperText={orderErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                        <Container className={styleClasses.container}>\r\n                            <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item className=\"step-math\">\r\n                                    <Slide direction=\"left\" triggerOnce>\r\n                                        <Card className={styleClasses.card}>\r\n                                            <CardContent className={styleClasses.cardContent}>\r\n                                                <TeX math={latexContent} block />\r\n                                            </CardContent>\r\n                                        </Card>\r\n                                    </Slide>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffFinite;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js",["216"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js",["217"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Button from '@material-ui/core/Button';\r\nimport ReplayIcon from '@material-ui/icons/Replay';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".points-input\",\r\n        title: \"Random Points\",\r\n        content:\r\n            \"Specify the number of random points.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".regenerate-button\",\r\n        title: \"Regenerate Random Points\",\r\n        content:\r\n            \"Click this to regenerate random points.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralMonteCarlo({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({x : 0});\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Random Points\r\n    const [points, setPoints] = useState(10000);\r\n    let pointsError = false;\r\n    let pointsErrorText = \"\";\r\n    if (isNaN(points) || !Number.isInteger(points) || points <= 0) {\r\n        pointsError = true;\r\n        pointsErrorText = \"Random points must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || pointsError;\r\n\r\n    // Solve\r\n    const plotDesmosPoints = 200;\r\n    let latexContent, graphCallback;\r\n    let results = [];\r\n    let solve = false;\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        \r\n        let yMin = 0;\r\n        let yMax = 0;\r\n\r\n        const divisions = 250;\r\n        const multiple = (upperX - lowerX) / divisions;\r\n\r\n        for (let i = 0; i <= divisions; i++) {\r\n            const x = lowerX + i * multiple;\r\n            const y = functionNode.evaluate({x : x});\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n            else if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n        }\r\n\r\n        const paddingX = 0;\r\n        const paddingY = 0;\r\n        let pointsInsidePositive = 0;\r\n        let pointsInsideNegative = 0;\r\n\r\n        for (let i = 0; i < points; i++) {\r\n            const randomX = lowerX - paddingX + (upperX - lowerX + 2 * paddingX) * Math.random();\r\n            const actualY = functionNode.evaluate({x : randomX});\r\n            const randomY = yMin - paddingY + (yMax - yMin + 2 * paddingY) * Math.random();\r\n            let inside = false;\r\n            if (actualY >= 0 && randomY >= 0 && randomY <= actualY) {\r\n                inside = true;\r\n                pointsInsidePositive += 1;\r\n            }\r\n            else if (actualY < 0 && randomY < 0 && randomY >= actualY) {\r\n                inside = true;\r\n                pointsInsideNegative += 1;\r\n            }\r\n            results.push({x: randomX, y: randomY, inside});\r\n        }\r\n        const rectArea = (yMax - yMin) * (upperX - lowerX);\r\n        const positiveIntegral = rectArea * pointsInsidePositive / points;\r\n        const negativeIntegral = rectArea * pointsInsideNegative / points;\r\n        const integralResult = positiveIntegral - negativeIntegral;\r\n        \r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{max} = ${formatLatex(yMax)}\r\n        \\\\ y_{min} = ${formatLatex(yMin)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Rectangle area} &=& y_{max} \\cdot y_{min} \\cdot x_{lower} \\cdot y_{upper}\r\n        \\\\                       &=&= ${formatLatex(rectArea)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Points inside positive area} &=& ${formatLatex(pointsInsidePositive)}\r\n        \\\\ \\text{Points inside negative area} &=& ${formatLatex(pointsInsideNegative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Positive area}&=& \\text{Rectangle area} \\cdot \\frac{\\text{Points inside positive area}}{\\text{Total points}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(rectArea)} \\cdot \\frac{${formatLatex(pointsInsidePositive)}}{${formatLatex(points)}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(positiveIntegral)}\r\n        \\\\\r\n        \\\\ \\text{Negative area}&=& \\text{Rectangle area} \\cdot \\frac{\\text{Points inside negative area}}{\\text{Total points}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(rectArea)} \\cdot \\frac{${formatLatex(pointsInsideNegative)}}{${formatLatex(points)}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(negativeIntegral)}\r\n        \\\\\r\n        \\\\ \\text{Total area/integral} &=& \\text{Positive area} - \\text{Negative area}\r\n        \\\\                   &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\"+functionLatex});\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\"+lowerX});\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\"+upperX});\r\n            calculator.current.setExpression({ id: 'shadedArea', latex: String.raw`\\left\\{f\\left(x\\right)>0:\\ 0,\\ f\\left(x\\right)<0:\\ f\\left(x\\right)\\right\\}<y<\\ \\left\\{f\\left(x\\right)>0:\\ f\\left(x\\right),\\ f\\left(x\\right)<0:\\ 0\\right\\}\\left\\{a<x<b,\\ b<x<a\\right\\}`});\r\n            calculator.current.setExpression({ id: 'leftVertical', color: Desmos.Colors.ORANGE, latex: String.raw`x=${lowerX} \\left\\{${yMin}<y<${yMax}\\right\\}`});\r\n            calculator.current.setExpression({ id: 'rightVertical', color: Desmos.Colors.ORANGE, latex: String.raw`x=${upperX} \\left\\{${yMin}<y<${yMax}\\right\\}`});\r\n            calculator.current.setExpression({ id: 'upperHori', color: Desmos.Colors.ORANGE, latex: String.raw`y=${yMax} \\left\\{${lowerX}<x<${upperX}\\right\\}`});\r\n            calculator.current.setExpression({ id: 'lowerHori', color: Desmos.Colors.ORANGE, latex: String.raw`y=${yMin} \\left\\{${lowerX}<x<${upperX}\\right\\}`});\r\n            if (results.length > plotDesmosPoints) {\r\n                for (let i = 0; i < plotDesmosPoints; i++) {\r\n                    const value = results[Math.floor(Math.random() * results.length)];\r\n                    calculator.current.setExpression({ id: `r${i}`, color: value.inside ? Desmos.Colors.GREEN : Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, latex: `(${value.x}, ${value.y})` });\r\n                }\r\n            }\r\n            else {\r\n                results.forEach((value, i) => {\r\n                    calculator.current.setExpression({ id: `r${i}`, color: value.inside ? Desmos.Colors.GREEN : Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, latex: `(${value.x}, ${value.y})` });\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    const [regenerate, setRegenerate] = useState(false); // For the purpose of refreshing the data\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        \r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"points-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Random points:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setPoints(parseInt(event.target.value))}\r\n                                        error={pointsError}\r\n                                        label={pointsError?\"Error\":\"\"}\r\n                                        defaultValue={points.toString()}\r\n                                        helperText={pointsErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Lower x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setLowerX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={lowerX.toString()}\r\n                                        helperText={lowerXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Upper x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setUpperX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={upperX.toString()}\r\n                                        helperText={upperXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                        <Container className={styleClasses.container}>\r\n                            <Button className=\"regenerate-button\" variant=\"contained\" color=\"primary\" endIcon={<ReplayIcon/>} onClick={() => setRegenerate(!regenerate)}>\r\n                                Regenerate\r\n                            </Button>\r\n                            <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item className=\"step-math\">\r\n                                    <Slide direction=\"left\" triggerOnce>\r\n                                        <Card className={styleClasses.card}>\r\n                                            <CardContent className={styleClasses.cardContent}>\r\n                                                <TeX math={latexContent} block />\r\n                                            </CardContent>\r\n                                        </Card>\r\n                                    </Slide>\r\n                                </Grid>\r\n                                <Grid xs item className=\"graph-button\">\r\n                                    <Slide direction=\"right\" triggerOnce>\r\n                                        <Graph params={{iterations: 0, functionLatex, graphCallback, smallScreen,\r\n                                        description: results.length > plotDesmosPoints ? `Only ${plotDesmosPoints} points are plotted for performance reasons.`:\"\"}} />\r\n                                    </Slide>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralMonteCarlo;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js",["218"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js",["219"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N, which must be even.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralSimpson({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({x : 0});\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n    else if (subIntervals % 2 !== 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be an even integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({x : x});\r\n            if (i === 0 || i === subIntervals){\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                if (i % 2 === 0){\r\n                    integralResult += 2 * f;\r\n                    results.push(2 * f);\r\n                }\r\n                else {\r\n                    integralResult += 4 * f;\r\n                    results.push(4 * f);\r\n                }\r\n            }\r\n        }\r\n        integralResult *= width / 3;\r\n        \r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{3} [f(x_0) + 4 \\sum_{i=1, odd}^{${subIntervals - 1}} f(x_i) + 2 \\sum_{j=2, even}^{${subIntervals - 2}} f(x_j) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            let coefficient = \"\";\r\n            if (i > 0 && i < subIntervals){\r\n                if (i % 2 === 0){\r\n                    coefficient = \"2\";\r\n                }\r\n                else {\r\n                    coefficient = \"4\";\r\n                }\r\n            }\r\n            latexContent += String.raw`${coefficient}f(${formatLatex(lowerX + i * width)}) ${i===subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i===subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\"+functionLatex});\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\"+lowerX});\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\"+upperX});\r\n            calculator.current.setExpression({ id: 'n', latex: \"n=\"+subIntervals});\r\n            calculator.current.setExpression({ id: 'g', latex: String.raw`g\\left(x\\right)=f\\left(x\\right)\\left\\{a\\le x\\le b\\right\\}`});\r\n            calculator.current.setExpression({ id: 'shade', color: Desmos.Colors.BLACK, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,g\\left(x\\right)\\right)\\le y\\le\\max\\left(0,g\\left(x\\right)\\right)`});\r\n            calculator.current.setExpression({ id: 'i', latex: String.raw`i=\\left[1...n\\right]`});\r\n            calculator.current.setExpression({ id: 'sOdd', latex: String.raw`S_{i3}=\\left[2,4,...n\\right]`});\r\n            calculator.current.setExpression({ id: 'x1', latex: String.raw`x_{1}=a+\\left(S_{i3}-2\\right)\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'x2', latex: String.raw`x_{2}=a+\\left(S_{i3}-1\\right)\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'x3', latex: String.raw`x_{3}=a+S_{i3}\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'simpsonShade', color: Desmos.Colors.RED, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,P\\left(x\\right)\\right)\\le y\\le\\max\\left(0,P\\left(x\\right)\\right)\\left\\{x_{1}\\le x\\le x_{3}\\right\\}`});\r\n            calculator.current.setExpression({ id: 'xLine1', color: Desmos.Colors.RED, latex: String.raw`x=a+\\left(i-1\\right)\\frac{b-a}{n}\\left\\{\\min\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\le y\\le\\max\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\right\\}`});\r\n            calculator.current.setExpression({ id: 'xLine2', color: Desmos.Colors.RED, latex: String.raw`x=b\\left\\{\\min\\left(0,f\\left(b\\right)\\right)\\le y\\le\\max\\left(0,f\\left(b\\right)\\right)\\right\\}`});\r\n            calculator.current.setExpression({ id: 'sn', latex: String.raw`S_{n}=\\frac{1}{3}\\cdot\\frac{b-a}{n}\\left(f\\left(a\\right)+\\sum_{t=1}^{\\frac{n}{2}}4f\\left(a+\\left(2t-1\\right)\\frac{b-a}{n}\\right)+\\sum_{t=1}^{\\frac{n}{2}-1}2f\\left(a+2t\\frac{b-a}{n}\\right)+f\\left(b\\right)\\right)`});\r\n            calculator.current.setExpression({ id: 'p', latex: String.raw`P\\left(x\\right)=f\\left(x_{1}\\right)\\cdot\\frac{x-x_{2}}{x_{1}-x_{2}}\\cdot\\frac{x-x_{3}}{x_{1}-x_{3}}+f\\left(x_{2}\\right)\\cdot\\frac{x-x_{1}}{x_{2}-x_{1}}\\cdot\\frac{x-x_{3}}{x_{2}-x_{3}}+f\\left(x_{3}\\right)\\cdot\\frac{x-x_{1}}{x_{3}-x_{1}}\\cdot\\frac{x-x_{2}}{x_{3}-x_{2}}\\left\\{x_{1}\\le x\\le x_{3}\\right\\}`});\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        If even subintervals, 2nd order polynomial/parabola.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"subIntervals-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Subintervals, N:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setSubIntervals(parseInt(event.target.value))}\r\n                                        error={subIntervalsError}\r\n                                        label={subIntervalsError?\"Error\":\"\"}\r\n                                        defaultValue={subIntervals.toString()}\r\n                                        helperText={subIntervalsErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Lower x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setLowerX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={lowerX.toString()}\r\n                                        helperText={lowerXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Upper x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setUpperX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={upperX.toString()}\r\n                                        helperText={upperXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                        <Container className={styleClasses.container}>\r\n                            <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item className=\"step-math\">\r\n                                    <Slide direction=\"left\" triggerOnce>\r\n                                        <Card className={styleClasses.card}>\r\n                                            <CardContent className={styleClasses.cardContent}>\r\n                                                <TeX math={latexContent} block />\r\n                                            </CardContent>\r\n                                        </Card>\r\n                                    </Slide>\r\n                                </Grid>\r\n                                <Grid xs item className=\"graph-button\">\r\n                                    <Slide direction=\"right\" triggerOnce>\r\n                                        <Graph params={{iterations: 0, functionLatex, graphCallback, smallScreen}} />\r\n                                    </Slide>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralSimpson;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js",["220"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js",[],["221","222"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js",["223","224","225"],"import {formatLatex, formatMatrixLatex} from \"../../utils\";\r\nimport {initialMatrix3 as initialMatrix, initialInputColumn3 as initialInputColumn, initialOutputColumn3 as initialOutputColumn,\r\ngenerateGridCallback, createNewColumn, createNewRow, gridTo2DArray, cloneArray,\r\nisDiagonallyDominant, numberFactorials, nextPermutation, generatePermutationMapping, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Link from '@material-ui/core/Link';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n        \"Choose either Jacobi or Gauss-Seidel.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n        \"Increase/Reduce the matrix's size\",\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n        \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".input-col-input\",\r\n        title: \"Input\",\r\n        content:\r\n        \"Specify the initial input vector.\",\r\n    },\r\n    {\r\n        target: \".output-col-input\",\r\n        title: \"Output\",\r\n        content:\r\n        \"Specify the output vector.\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearJacobiSeidel({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n        \r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const [inputColumnState, setInputColumnState] = useState(initialInputColumn);\r\n    const [outputColumnState, setOutputColumnState] = useState(initialOutputColumn);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            const inputColumns = inputColumnState.columns.slice();\r\n            const inputRows = inputColumnState.rows.slice();\r\n            const outputColumns = outputColumnState.columns.slice();\r\n            const outputRows = outputColumnState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n                inputColumns.push(createNewColumn(inputColumns.length));\r\n                inputRows[0][`col_${inputColumns.length}`] = 0;\r\n                outputColumns.push(createNewColumn(outputColumns.length));\r\n                outputRows[0][`col_${outputColumns.length}`] = 0;\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < outputRows.length; i++) {\r\n                    delete outputRows[i][`col_${outputColumns.length}`];\r\n                }\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n                for (let i = 0; i < inputRows.length; i++) {\r\n                    delete inputRows[i][`col_${inputColumns.length}`];\r\n                }\r\n                inputColumns.pop();\r\n                outputColumns.pop();\r\n            }\r\n            setGridState({columns, rows});\r\n            setInputColumnState({columns: inputColumns, rows: inputRows});\r\n            setOutputColumnState({columns: outputColumns, rows: outputRows});\r\n        };\r\n    }\r\n\r\n    // Solver Type\r\n    const [solverType, setSolverType] = useState(\"jacobi\");\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0002);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const originalOutput = gridTo2DArray(outputColumnState.rows)[0];\r\n    const originalInput = gridTo2DArray(inputColumnState.rows)[0];\r\n    let modifiedInput = cloneArray(originalInput);\r\n    const matrixSize = gridState.rows.length;\r\n    let results = [];\r\n    let iterations = 0;\r\n    let permutated = false;\r\n    let triedPermutating = false; // Failed to obtain a dominant matrix even after permutating.\r\n    if (!hasError) {\r\n        solve = true;\r\n        let dominant = false; // Strictly diagonally dominant\r\n        let modifiedMatrix = cloneArray(originalMatrix);\r\n        let modifiedOutput = cloneArray(originalOutput);\r\n        console.log(\"Original: \", modifiedMatrix);\r\n        if (!isDiagonallyDominant(modifiedMatrix)) {\r\n            console.log(\"Initially not dominant!\");\r\n            let numPermutations = numberFactorials[matrixSize];\r\n            let rowIndexes = [...Array(matrixSize).keys()];\r\n            for (let i = 0; i < numPermutations - 1; i++) {\r\n                nextPermutation(rowIndexes);\r\n                const permutatedMatrix = rowIndexes.map(ind => modifiedMatrix[ind]);\r\n                if (isDiagonallyDominant(permutatedMatrix)) {\r\n                    dominant = true;\r\n                    modifiedMatrix = permutatedMatrix;\r\n                    modifiedOutput = rowIndexes.map(ind => modifiedOutput[ind]);\r\n                    console.log(\"Found a dominant!\", modifiedMatrix, modifiedOutput, rowIndexes);\r\n                    break;\r\n                }\r\n            }\r\n            if (dominant) {\r\n                results.push({\r\n                    newMatrix: cloneArray(modifiedMatrix),\r\n                    newOutput: cloneArray(modifiedOutput),\r\n                    newInput: cloneArray(modifiedInput),\r\n                    permutated: true,\r\n                    rowIndexes: rowIndexes,\r\n                });\r\n                permutated = true;\r\n                iterations += 1;\r\n            }\r\n            else {\r\n                console.log(\"Tried permutating but failed!\");\r\n                triedPermutating = true;\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"Initially dominant!\");\r\n            dominant = true;\r\n        }\r\n        \r\n        if (dominant) {\r\n            console.log(\"Solve Dominant!\");\r\n            let i = 0;\r\n            while (true) {\r\n                let oldInput = (i === 0) ? originalInput : results[i - 1 + iterations].newInput;\r\n                let newInput = [];\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    let sum = modifiedOutput[j];\r\n                    if (solverType === \"jacobi\") {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k !== j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k < j) {\r\n                                sum -= modifiedMatrix[j][k] * newInput[k];\r\n                            }\r\n                            else if (k > j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    sum /= modifiedMatrix[j][j];\r\n                    newInput.push(sum);\r\n                }\r\n                let errorInput = newInput.map((v, index) => Math.abs(v - oldInput[index]));\r\n                let converged = true;\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    if (errorInput[j] >= errorThreshold) {\r\n                        converged = false;\r\n                        break;\r\n                    }\r\n                }\r\n                results.push({\r\n                    oldInput,\r\n                    newInput,\r\n                    errorInput,\r\n                    converged,\r\n                });\r\n                \r\n                i++;\r\n                if (converged) {\r\n                    console.log(\"Converged\");\r\n                    break;\r\n                }\r\n                if (i > 1000) {\r\n                    console.log(\"Exceeded 1000 iterations!\");\r\n                    exceedIterError = true;\r\n                    exceedIterErrorText = \"Exceeded 1000 iterations! Try increasing the error threshold.\";\r\n                    break;\r\n                }\r\n            }\r\n            iterations += i;\r\n        }\r\n    }\r\n    console.log(results);\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {solverType, originalMatrix, originalInput, originalOutput, matrixSize, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results, permutated, triedPermutating};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied to matrices in the form of\r\n                        <TeX math={String.raw`\\ Ax=B`} /> .\r\n                        <br/>\r\n                        Warning: The process of finding a diagonally-dominant form may be slow for matrices 7x7 and beyond\r\n                        <br/>\r\n                        because it needs to search through all the possible permutations.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"h6\">\r\n                                                Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                            </Typography>\r\n                                            <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event)=>setSolverType(event.target.value)}>\r\n                                                <FormControlLabel value=\"jacobi\" control={<Radio />} label=\"Jacobi\" />\r\n                                                <FormControlLabel value=\"seidel\" control={<Radio />} label=\"Gauss-Seidel\" />\r\n                                            </RadioGroup>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"h6\">\r\n                                                Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                            </Typography>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                            </IconButton>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                <AddCircleOutlineOutlinedIcon />\r\n                                            </IconButton>\r\n                                        </Grid>\r\n\r\n                                        <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Matrix, A:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={0} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={gridState.columns}\r\n                                                        rowGetter={i => gridState.rows[i]}\r\n                                                        rowsCount={gridState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n\r\n                                        <Grid xs item className=\"input-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Initial Input, <TeX math={String.raw`X^{(0)}`} />:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={inputColumnState.columns}\r\n                                                        rowGetter={i => inputColumnState.rows[i]}\r\n                                                        rowsCount={inputColumnState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(inputColumnState, setInputColumnState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * inputColumnState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * inputColumnState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"output-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Output, B:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={2} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={outputColumnState.columns}\r\n                                                        rowGetter={i => outputColumnState.rows[i]}\r\n                                                        rowsCount={outputColumnState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(outputColumnState, setOutputColumnState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * outputColumnState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * outputColumnState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"errorThreshold-input\">\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Error threshold:\r\n                                                    </Typography>\r\n                                                    <TextField\r\n                                                        disabled={false}\r\n                                                        type=\"number\"\r\n                                                        onChange={(event)=>setErrorThreshold(parseFloat(event.target.value))}\r\n                                                        error={thresholdError}\r\n                                                        label={thresholdError?\"Error\":\"\"}\r\n                                                        defaultValue={errorThreshold.toString()}\r\n                                                        helperText={thresholdErrorText}\r\n                                                        variant=\"outlined\"\r\n                                                    />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Grid>\r\n                                    </Grid>                                    \r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({smallScreen, params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n    let latexContent;\r\n\r\n    if (currentIteration <= 0) {\r\n        setCurrentIteration(1);\r\n    }\r\n    else if (params.iterations > 0 && currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else if (params.triedPermutating) {\r\n        // Failed even after permutating the matrix\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\text{Cannot find a diagonally dominant matrix.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, {leftBracketOnly: true})}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, {single: true})}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, {single: true})}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n    else if (params.iterations > 0) {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\begin{array}{lcl}\r\n        `;\r\n        if (currentResult.permutated) {\r\n            const permutationMapping = generatePermutationMapping(currentResult.rowIndexes);\r\n            const boldRows = Object.keys(permutationMapping).map((v) => parseInt(v) + 1);\r\n            boldRows.push(...Object.values(permutationMapping).map((v) => v + 1));\r\n            const previousLatex = String.raw`\r\n            \\overbrace{${matrixToLatex(params.originalMatrix, {leftBracketOnly: true, boldRows: boldRows})}}^{A}\r\n            \\overbrace{${matrixToLatex(params.originalOutput, {single:true, rightBracketOnly:true, boldRows: boldRows})}}^{B}`;\r\n            let operationLatex =  String.raw`\\begin{array}{l}`;\r\n            for (const [key, value] of Object.entries(permutationMapping)) {\r\n                operationLatex += String.raw`R_{${parseInt(key) + 1}} \\leftrightarrow R_{${value + 1}}\\\\`;\r\n            }\r\n            operationLatex += String.raw`\\end{array}`;\r\n            const newLatex= String.raw`\r\n            \\overbrace{${matrixToLatex(currentResult.newMatrix, {leftBracketOnly:true, boldRows: boldRows})}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.newOutput, {single:true, rightBracketOnly:true, boldRows: boldRows})}}^{B}`;\r\n            latexContent += String.raw`\r\n            \\\\ \\text{The matrix's rows are } \\textbf{permutated} ${smallScreen?\"\\\\\\\\\":\"\"} \\text{ to make it } \\textbf{strictly diagonally dominant.}\r\n            \\\\`\r\n            if (smallScreen) {\r\n                latexContent += String.raw`\r\n                \\\\ ${previousLatex}\r\n                \\\\ \\begin{array}{lcl}\r\n                    & \\downarrow &\r\n                    \\\\ & ${operationLatex} &\r\n                    \\\\ & \\downarrow &\r\n                    \\end{array}\r\n                \\\\ ${newLatex}\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ ${previousLatex}\r\n                    & \\overrightarrow{${operationLatex}}\r\n                    & ${newLatex}\r\n                    \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            let index = params.permutated ? currentIteration - 1: currentIteration;\r\n            let matrix = params.permutated ? results[0].newMatrix : params.originalMatrix;\r\n            let output = params.permutated ? results[0].newOutput : params.originalOutput;\r\n            let solverExpressionLatex = params.solverType === \"jacobi\" ?\r\n            String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1, \\\\ j \\ne i}}^n \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n                \\right]`\r\n            :\r\n            String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1}}^{i-1} \\left( A_{ij} \\cdot X^{(${index})}_j \\right)\r\n                           - \\sum_{\\substack{j = i+1}}^{n} \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n\r\n                \\right]`;\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\overbrace{${matrixToLatex(matrix, {leftBracketOnly:true})}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.oldInput, {single: true})}}^{X^{(${index - 1})}}\r\n            = \\overbrace{${matrixToLatex(output, {single:true})}}^{B}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${solverExpressionLatex}\r\n            \\\\\r\n            \\\\ &=& \\left[\\begin{matrix}\r\n            `;\r\n            for (let i = 0; i < params.matrixSize; i++) {\r\n                latexContent += String.raw`\\frac{1}{${formatMatrixLatex(matrix[i][i])}} \\left[ ${formatMatrixLatex(output[i])}`;\r\n                if (params.solverType === \"jacobi\") {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j !== i) {\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j < i) {\r\n                            //sum -= modifiedMatrix[i][j] * newInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.newInput[j])}) `;\r\n                        }\r\n                        else if (j > i) {\r\n                            //sum -= modifiedMatrix[i][j] * oldInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                latexContent += String.raw`\\right] \\cr`;\r\n            }\r\n\r\n            latexContent += String.raw`\r\n            \\end{matrix}\\right]\r\n            \\\\\r\n            \\\\ X^{(${index})} &=& ${matrixToLatex(currentResult.newInput, {single: true})}\r\n            \\end{array}\r\n            `;\r\n            if (results[0].permutated) {\r\n                // Reorder the equations\r\n                let restoredOutput = cloneArray(currentResult.newInput);\r\n                restoredOutput = results[0].rowIndexes.map(ind => restoredOutput[ind]);\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text {Given that the matrix A has been permutated in iteration 1, }\r\n                \\\\ \\text {we must restore it to the original order:}\r\n                \\\\\r\n                \\\\ X^{(${index})}_{restored} = ${matrixToLatex(restoredOutput, {single: true})}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ Error &=& |X^{(${index})} - X^{(${index - 1})}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorInput)}|\r\n            \\end{array}\r\n            `;\r\n            if (currentResult.converged) {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Converged because:}\r\n                \\\\\r\n                \\\\ Error < Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorInput)} < ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n        \r\n    }\r\n    else {\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Cannot do anything.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, {leftBracketOnly: true})}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, {single: true})}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, {single: true})}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={currentIteration}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations<=0 ? 1 :params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iteration {currentIteration}:\r\n                                    </Typography>\r\n                                    <TeX math={latexContent} />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearJacobiSeidel;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js",["226"],"import {formatMatrixLatex} from \"../../utils\";\r\nimport {initialMatrix6 as initialMatrix, generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, matrixToLatex, cloneArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { transpose, multiply, identity } from 'mathjs';\r\nimport {Matrix as MLMatrix, EigenvalueDecomposition as MLEigen} from 'ml-matrix';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport { Zoom } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".matrix-col-input\",\r\n        title: \"Column\",\r\n        content:\r\n        \"Add/Remove columns\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-row-input\",\r\n        title: \"Row\",\r\n        content:\r\n        \"Add/Remove rows\",\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n        \"Specify the matrix here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearPenrose({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n        \r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const columnCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n            }\r\n            setGridState({columns, rows});\r\n        };\r\n    }\r\n    const rowCallback = (add) => {\r\n        return () => {\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                rows.push(createNewRow(gridState.columns.length));\r\n            }\r\n            else {\r\n                if (rows.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n            }\r\n            setGridState({...gridState, rows});\r\n        };\r\n    }\r\n\r\n    // Solve\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const rowLength = gridState.rows.length; // row dimension\r\n    const colLength = gridState.columns.length; // column dimension\r\n\r\n    /*\r\n    const multiplyTranspose = multiply(transpose(originalMatrix), originalMatrix); // AT*A\r\n    const multiplyTransposeEigen = eigs(multiplyTranspose);\r\n    const multiplyTransposeSingularValues = multiplyTransposeEigen.values.slice().reverse().map((v) => Math.sqrt(v));\r\n    const transposeMultiply = multiply(originalMatrix, transpose(originalMatrix)); // A*AT\r\n    const transposeMultiplyEigen = eigs(transposeMultiply);\r\n    const transposeMultiplySingularValues = transposeMultiplyEigen.values.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    let rightUnitaryT = transpose(multiplyTransposeEigen.vectors).reverse();\r\n    let rightUnitary = transpose(rightUnitaryT);\r\n\r\n    let leftUnitaryT = transpose(transposeMultiplyEigen.vectors).reverse();\r\n    let leftUnitary = transpose(leftUnitaryT);\r\n    */\r\n\r\n    const multiplyTranspose = multiply(originalMatrix, transpose(originalMatrix)); // A*AT\r\n    const multiplyTransposeEigen = new MLEigen(new MLMatrix(multiplyTranspose));\r\n    const multiplyTransposeEigenMatrix = Array.from(multiplyTransposeEigen.eigenvectorMatrix.data.map((v) => Array.from(v)));\r\n    const multiplyTransposeSingularValues = multiplyTransposeEigen.realEigenvalues.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    const transposeMultiply = multiply(transpose(originalMatrix), originalMatrix); // AT*A\r\n    const transposeMultiplyEigen = new MLEigen(new MLMatrix(transposeMultiply));\r\n    const transposeMultiplyEigenMatrix = Array.from(transposeMultiplyEigen.eigenvectorMatrix.data.map((v) => Array.from(v)));\r\n    const transposeMultiplyEigenValues = transposeMultiplyEigen.realEigenvalues.slice().reverse();\r\n    const transposeMultiplySingularValues = transposeMultiplyEigen.realEigenvalues.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    let rightUnitaryT = transpose(transposeMultiplyEigenMatrix).reverse();\r\n    let rightUnitary = transpose(rightUnitaryT);\r\n    let leftUnitaryT = transpose(multiplyTransposeEigenMatrix).reverse();\r\n    let leftUnitary = transpose(leftUnitaryT);\r\n\r\n    let diagonal = [];\r\n    if (rowLength <= colLength) {\r\n        for (let i = 0; i < rowLength; i++) {\r\n            diagonal.push(Array(colLength).fill(0));\r\n            if (i < colLength) {\r\n                diagonal[i][i] = multiplyTransposeSingularValues[i];\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < rowLength; i++) {\r\n            diagonal.push(Array(colLength).fill(0));\r\n            if (i < colLength) {\r\n                diagonal[i][i] = transposeMultiplySingularValues[i];\r\n            }\r\n        }\r\n    }\r\n    console.log(\"Ori\", diagonal);\r\n    let diagonalInverse = cloneArray(diagonal);\r\n    for (let i = 0; i < rowLength; i++) {\r\n        if (i < colLength && diagonalInverse[i][i] !== 0) {\r\n            diagonalInverse[i][i] = 1 / diagonalInverse[i][i];\r\n        }\r\n    }\r\n    diagonalInverse = transpose(diagonalInverse);\r\n    const pseudoInverse = multiply(rightUnitary, multiply(diagonalInverse, leftUnitaryT));\r\n    const productInverseRight = multiply(originalMatrix, pseudoInverse); // Right inverse\r\n    const productInverseLeft = multiply(pseudoInverse, originalMatrix); // Right inverse\r\n\r\n    let latexContent = String.raw`\r\n    \\displaystyle\r\n    \\begin{array}{l}\r\n    \\begin{array}{lcl}\r\n    \\\\ AA^{T} = ${matrixToLatex(multiplyTranspose)}\r\n    \\\\\r\n    \\\\ \\text{The eigenvectors of } AA^{T}:\r\n    \\\\\r\n    \\\\ \\bf{U} = \\left[\\begin{matrix}`;\r\n\r\n    for (let i = 0 ; i < multiplyTransposeEigenMatrix.length; i++) {\r\n        latexContent += String.raw` v_{${i + 1}} ${i === multiplyTransposeEigenMatrix.length - 1 ? '': '&'} `;\r\n    }\r\n\r\n    latexContent += String.raw`\r\n    \\end{matrix}\\right] = ${matrixToLatex(leftUnitary)}\r\n    \\\\ \r\n    \\\\ \\hline\r\n    \\\\\r\n    \\\\ A^{T}A = ${matrixToLatex(transposeMultiply)}\r\n    \\\\\r\n    \\\\\r\n    \\\\ \\text{The eigenvectors of } A^{T}A:\r\n    \\\\\r\n    \\\\ \\bf{V^{T}} = \\left[\\begin{matrix}`;\r\n\r\n    for (let i = 0 ; i < transposeMultiplyEigenMatrix.length; i++) {\r\n        latexContent += String.raw` v_{${i + 1}}\\cr `;\r\n    }\r\n\r\n    latexContent += String.raw`\r\n    \\end{matrix}\\right] = ${matrixToLatex(rightUnitaryT)}\r\n    \\\\ \r\n    \\begin{array}{lcl}\r\n    \\\\ \\text{The eigenvalues of } A^{T}A &=& ${transposeMultiplyEigenValues.filter((v) => !isNaN(v)).map((v) => formatMatrixLatex(v))}\r\n    \\\\\r\n    \\\\ \\text{The singular values,} \\ \\sigma &=& \\sqrt{\\text{Eigenvalues}}\r\n    \\\\          &=& ${transposeMultiplySingularValues.filter((v) => !isNaN(v)).map((v) => formatMatrixLatex(v))}\r\n    \\end{array}\r\n    \\\\\r\n    \\\\ \\bf{D} = \\left[\\begin{matrix}`;\r\n    for (let i = 0; i < rowLength; i++) {\r\n        for (let j = 0; j < colLength; j++) {\r\n            if (j === i) {\r\n                latexContent += String.raw`\\colorbox{aqua}{\\bf{${formatMatrixLatex(diagonal[i][j])}}}`;\r\n            }\r\n            else {\r\n                latexContent += String.raw`${formatMatrixLatex(diagonal[i][j])}`;\r\n            }\r\n            if (j !== colLength - 1) {\r\n                latexContent += String.raw`&`;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\cr`;\r\n    }\r\n\r\n   latexContent += String.raw`\r\n    \\end{matrix}\\right]\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\begin{array}{lcl}\r\n    \\\\ A &=& ${matrixToLatex(originalMatrix)}\r\n    \\\\\r\n    \\\\ U^{T} &=& ${matrixToLatex(leftUnitaryT)}\r\n    \\\\\r\n    \\\\ D^{+} &=& \\text{Reciprocal of the singular values}\r\n    \\\\\r\n    \\\\       &=& ${matrixToLatex(diagonalInverse)}\r\n    \\\\\r\n    \\\\ V &=& ${matrixToLatex(rightUnitary)}\r\n    \\\\\r\n    \\\\ A^{-1} &=& V D^{+} U^{T}\r\n    \\\\\r\n    \\\\   &=& ${matrixToLatex(rightUnitary)} ${matrixToLatex(diagonalInverse)} ${matrixToLatex(leftUnitaryT)}\r\n    \\\\\r\n    \\\\   &=& ${matrixToLatex(pseudoInverse)}\r\n    \\\\ \\end{array}\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\text{To verify the pseudoinverse,}\r\n    \\\\ \\begin{array}{lcl}\r\n    \\\\ AA^{-1} &=& ${matrixToLatex(originalMatrix)} ${matrixToLatex(pseudoInverse)}\r\n    \\\\\r\n    \\\\         &=& ${matrixToLatex(productInverseRight)}\r\n    \\\\\r\n    \\\\ A^{-1}A &=& ${matrixToLatex(pseudoInverse)} ${matrixToLatex(originalMatrix)}\r\n    \\\\\r\n    \\\\         &=& ${matrixToLatex(productInverseLeft)}\r\n    \\\\ \\end{array}\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\text{In some cases, } AA^{-1} \\ne I \\text{  or  } A^{-1}A \\ne I \\text{  or even both!}\r\n    \\\\ \\text{The error could be very small due to rounding error. }\r\n    \\\\ \\text{Otherwise, if the error is really huge or if the signs are reversed, this is because the my naive SVD algorithm sometimes}\r\n    \\\\ \\text{fails to properly realign the eigenvector matrices.}\r\n    \\\\ \\text{I'm too lazy to rectify this, sorry!}\r\n    \\end{array}\\end{array}\r\n    `;\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                    Note: Errors may occur depending on the matrix used\r\n                    <br/>\r\n                    because I've not perfected the algorithm yet.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"matrix-col-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"subtitle1\">\r\n                                                Columns:\r\n                                            </Typography>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={columnCallback(false)}>\r\n                                                <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                            </IconButton>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={columnCallback(true)}>\r\n                                                <AddCircleOutlineOutlinedIcon  />\r\n                                            </IconButton>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"matrix-row-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"subtitle1\">\r\n                                                Rows:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                            </Typography>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={rowCallback(false)} >\r\n                                                <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                            </IconButton>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={rowCallback(true)} >\r\n                                                <AddCircleOutlineOutlinedIcon />\r\n                                            </IconButton>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Matrix, A:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={0} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={gridState.columns}\r\n                                                        rowGetter={i => gridState.rows[i]}\r\n                                                        rowsCount={gridState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </Grid>                                    \r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Container className={styleClasses.container}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <TeX math={latexContent} block />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                </Grid>\r\n            </Container>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default LinearPenrose;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js",["227"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js",["228"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js",["229"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix22 as initialMatrix, generateGridCallback, gridTo2DArray, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, inv, multiply } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst FUNCTIONS = ['0', '-4','0'];\r\nconst FUNCTIONS_TEXT = ['0', '-4','0'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of a, b, f(a) and f(b).\",\r\n    },\r\n    {\r\n        target: \".points-input\",\r\n        title: \"Number of points\",\r\n        content:\r\n            \"Specify the number of points in between the lower and upper boundaries.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeFiniteDiff({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatexs, setFunctionLatexs] = useState(FUNCTIONS);\r\n    const [functionTexts, setFunctionTexts] = useState(FUNCTIONS_TEXT);\r\n\r\n    const functionLatexsRef= useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef= useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = Array(3).fill(false);\r\n    let functionErrorTexts = Array(3).fill(\"\");\r\n\r\n    for (let i = 0; i < 3; i++){\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (node.name !== 'x') {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate({x : 0});\r\n        }\r\n        catch(e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    const [lowerX, upperX] = [initialVector[0], initialVector[2]]; \r\n    let intervalError = false;\r\n    let intervalErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        intervalErrorText = \"a must be lower than b!\";\r\n    }\r\n\r\n    // Points\r\n    const [points, setPoints] = useState(9);\r\n    let pointsError = false;\r\n    let pointsErrorText = \"\";\r\n    if (!Number.isInteger(points) || points <= 0) {\r\n        pointsError = true;\r\n        pointsErrorText = \"Number of points must be a positive integer!\";\r\n    }\r\n    const iterations = points + 1;\r\n\r\n    const functionsError = !functionErrors.every((e) => e === false);\r\n    let hasError = functionsError || intervalError || pointsError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let stepSize, xArray;\r\n    let resultsMatrix = [];\r\n    let resultsColumn = [];\r\n    let resultsInverse, resultsSolved;\r\n    let results = [];\r\n    let latexContent, graphCallback;\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        stepSize = (upperX - lowerX) / iterations;\r\n        xArray = [...Array(iterations).keys()].map((i) => stepSize * (i + 1));\r\n        for (let iter = 1; iter < iterations; iter++) {\r\n            const currentX = xArray[iter - 1];\r\n            const pResult = functionNodes[0].evaluate({x: currentX});\r\n            const qResult = functionNodes[1].evaluate({x: currentX});\r\n            const fResult = functionNodes[2].evaluate({x: currentX});\r\n\r\n            const previousYCoeff = (1 - stepSize / 2 * pResult);\r\n            const currentYCoeff = Math.pow(stepSize, 2) * qResult - 2;\r\n            const nextYCoeff = (1 + stepSize / 2 * pResult);\r\n            const row = Array(iterations - 1).fill(0);\r\n            row[iter - 1] = currentYCoeff;\r\n\r\n            let additionalConstant = 0;\r\n            if (iter === 1) {\r\n                additionalConstant = previousYCoeff * initialVector[1];\r\n            }\r\n            else {\r\n                row[iter - 2] = previousYCoeff;\r\n            }\r\n            if (iter === iterations - 1) {\r\n                additionalConstant = nextYCoeff * initialVector[3];\r\n            }\r\n            else {\r\n                row[iter] = nextYCoeff;\r\n            }\r\n            resultsMatrix.push(row);\r\n            resultsColumn.push(Math.pow(stepSize, 2) * fResult - additionalConstant)\r\n        }\r\n        resultsInverse = inv(resultsMatrix);\r\n        resultsSolved = multiply(resultsInverse, resultsColumn);\r\n\r\n        for (let i = 0; i < iterations; i++) {\r\n            results.push({\r\n                currentX: (i === 0) ? initialVector[0] : xArray[i - 1],\r\n                newX: xArray[i],\r\n                currentY: (i === 0) ? initialVector[1] : resultsSolved[i - 1],\r\n                newY: (i === iterations - 1) ? initialVector[3] : resultsSolved[i]\r\n            });\r\n        }\r\n        let yColumnLatex = String.raw`\\left[\\begin{matrix} `;\r\n        for (let i = 1 ; i < iterations; i++) {\r\n            yColumnLatex += String.raw` y_{${i}}\\cr `;\r\n        }\r\n        yColumnLatex += String.raw` \\end{matrix}\\right] `;\r\n\r\n        const limit = 30;\r\n        const tooManyLatex = String.raw`\\left[\\begin{matrix}\r\n               & \\dots  &        \\cr\r\n        \\vdots & \\ddots & \\vdots \\cr\r\n               & \\dots  &        \\cr\r\n        \\end{matrix}\\right]`;\r\n        const tooManyColumnLatex = String.raw`\\left[\\begin{matrix}\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\end{matrix}\\right]`;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& ${formatLatex(stepSize)}\r\n        \\\\ y_{0} &=& ${initialVector[1]}\r\n        \\\\ y_{${iterations}} &=& ${initialVector[3]}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\\\ \\text{From the equation } (1 + \\frac{h}{2} P_i) y_{i+1} + (h^{2} Q_{i} - 2) + (1 - \\frac{h}{2} P_i) y_{i-1} = h^{2} f_{i} \\text{ ,}\r\n        \\\\ \\begin{array}{rcl}\r\n        \\\\ ${ iterations > limit ? tooManyLatex : matrixToLatex(resultsMatrix)} ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, {single: true})}\r\n        \\\\\r\n        \\\\                                 ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, {single: true})} ${iterations > limit ? \"\": matrixToLatex(resultsInverse)}\r\n        \\\\\r\n        \\\\                                 ${yColumnLatex} &=& ${matrixToLatex(resultsSolved, {single: true})}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < iterations; i++){\r\n                const r = results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {iterations, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`y^{''} + P(x)y^{'} + Q(x)y = f(x)`} />.\r\n                    </Typography>\r\n                    <Divider />\r\n                    <Grid xs item className=\"functions-display\">\r\n                        <Box border={1} borderRadius={5} boxShadow={2}>\r\n                            <Collapse in={!hasError}>\r\n                                {!functionsError && <Fade triggerOnce>\r\n                                <TeX math={String.raw`y^{''} + (${functionLatexs[0]}) y^{'} + (${functionLatexs[1]}) y = ${functionLatexs[2]}`} block />\r\n                                </Fade>}\r\n                            </Collapse>\r\n                        </Box>\r\n                    </Grid>\r\n                    <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`P(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[0]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(0, mathField.text());\r\n                                            setSpecificFunctionLatex(0, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[0]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[0]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`Q(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[1]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(1, mathField.text());\r\n                                            setSpecificFunctionLatex(1, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[1]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[1]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`F(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[2]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(2, mathField.text());\r\n                                            setSpecificFunctionLatex(2, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[2]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[2]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                                <Collapse in={intervalError}>\r\n                                    <Alert severity=\"error\">\r\n                                        {intervalErrorText}\r\n                                    </Alert>\r\n                                </Collapse>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"points-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Number of Points between Boundaries:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setPoints(parseInt(event.target.value))}\r\n                                        error={pointsError}\r\n                                        label={pointsError?\"Error\":\"\"}\r\n                                        defaultValue={points.toString()}\r\n                                        helperText={pointsErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && \r\n                            <Container className={styleClasses.container}>\r\n                                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"graph-button\">\r\n                                        <Slide direction=\"right\" triggerOnce>\r\n                                            <Graph params={{currentIteration : 1, graphCallback, smallScreen, ...params}} />\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"step-math\">\r\n                                            <Zoom duration={500} triggerOnce>\r\n                                                <Card className={styleClasses.card}>\r\n                                                    <CardContent className={styleClasses.cardContent}>\r\n                                                        <TeX math={latexContent} block />\r\n                                                    </CardContent>\r\n                                                </Card>\r\n                                            </Zoom>\r\n                                        </Grid>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default OdeFiniteDiff;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js",["230"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeRunge({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({x : 0, y : 0});\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const k1 = functionNode.evaluate({x: currentX, y: currentY});\r\n            const k2 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k1 * stepHalf});\r\n            const k3 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k2 * stepHalf});\r\n            const k4 = functionNode.evaluate({x: currentX + stepSize, y: currentY + k3 * stepSize});\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, initialVector, stepSize, iterations, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ k_1 &=& f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n        \\\\    &=& ${formatLatex(currentResult.k1)}\r\n        \\\\\r\n        \\\\ k_2 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_1 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k2)}\r\n        \\\\\r\n        \\\\ k_3 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_2 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k3)}\r\n        \\\\\r\n        \\\\ k_4 &=& f(x_{${currentIteration - 1}} + h, y_{${currentIteration - 1}} + k_1 \\cdot h)\r\n        \\\\    &=& ${formatLatex(currentResult.k4)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array} \\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeRunge;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js",["231"],"import {isValidMath, mathjsToLatex, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix21 as initialMatrix, generateGridCallback, gridTo2DArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, simplify } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst FUNCTIONS = ['0', '4','-4 x'];\r\nconst FUNCTIONS_TEXT = ['0', '4','-4 x'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n        \"Choose either Euler or Runge-Kutta.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of a, b, f(a) and f(b).\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the selected method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeShooting({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Solver mode: Euler or Runge\r\n    const [solverType, setSolverType] = useState('runge');\r\n\r\n    // Function\r\n    const [functionLatexs, setFunctionLatexs] = useState(FUNCTIONS);\r\n    const [functionTexts, setFunctionTexts] = useState(FUNCTIONS_TEXT);\r\n\r\n    const functionLatexsRef= useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef= useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = Array(3).fill(false);\r\n    let functionErrorTexts = Array(3).fill(\"\");\r\n\r\n    for (let i = 0; i < 3; i++){\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (node.name !== 'x') {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate({x : 0});\r\n        }\r\n        catch(e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    const [lowerX, upperX] = [initialVector[0], initialVector[2]]; \r\n    let intervalError = false;\r\n    let intervalErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        intervalErrorText = \"a must be lower than b!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    const functionsError = !functionErrors.every((e) => e === false);\r\n    let hasError = functionsError || intervalError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let stepSize, xArray;\r\n    let f1Node, f2Node;\r\n    let results1 = {y: [], u: []}; // First solution\r\n    let results2 = {y: [], u: []}; // Second solution\r\n    let results = []; // Final solution\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        stepSize = (upperX - lowerX) / iterations;\r\n        xArray = [...Array(iterations).keys()].map((i) => stepSize * (i + 1));\r\n        const stepHalf = stepSize / 2;\r\n        const generateResults = (resultsArray, node, initialValues) => {\r\n            for (let iter = 0; iter < iterations; iter++) {\r\n                // Get current values\r\n                const currentX = (iter === 0) ? initialVector[0] : xArray[iter - 1];\r\n                const currentY = (iter === 0) ? initialValues[0] : resultsArray.y[iter - 1].newValue;\r\n                const currentU = (iter === 0) ? initialValues[1] : resultsArray.u[iter - 1].newValue;\r\n\r\n                // Find new values\r\n                if (solverType === 'runge') {\r\n                    // k1\r\n                    const k1Y = currentU;\r\n                    const k1U = node.evaluate({x: currentX, 'y': currentY, 'u': currentU});\r\n\r\n                    // k2\r\n                    const k2Y = currentU + k1U * stepHalf;\r\n                    const k2U = node.evaluate({x: currentX + stepHalf, 'y': currentY + k1Y * stepHalf, 'u': currentU + k1U * stepHalf});\r\n\r\n                    // k3\r\n                    const k3Y = currentU + k2U * stepHalf;\r\n                    const k3U = node.evaluate({x: currentX + stepHalf, 'y': currentY + k2Y * stepHalf, 'u': currentU + k2U * stepHalf});\r\n\r\n                    // k4\r\n                    const k4Y = currentU + k3U * stepSize;\r\n                    const k4U = node.evaluate({x: currentX + stepSize, 'y': currentY + k3Y * stepSize, 'u': currentU + k3U * stepSize});\r\n                    \r\n                    const newY = currentY + stepSize / 6 * (k1Y + 2 * k2Y + 2 * k3Y + k4Y);\r\n                    const newU = currentU + stepSize / 6 * (k1U + 2 * k2U + 2 * k3U + k4U);\r\n                    resultsArray.y.push({currentValue: currentY, newValue: newY, k1: k1Y, k2: k2Y, k3: k3Y, k4: k4Y});\r\n                    resultsArray.u.push({currentValue: currentU, newValue: newU, k1: k1U, k2: k2U, k3: k3U, k4: k4U});\r\n                }\r\n                else {\r\n                    const uResult = node.evaluate({x: currentX, 'y': currentY, 'u': currentU});\r\n                    const newY = currentY + stepSize * currentU;\r\n                    const newU = currentU + stepSize * uResult;\r\n                    resultsArray.y.push({currentValue: currentY, newValue: newY, functionResult: currentU});\r\n                    resultsArray.u.push({currentValue: currentU, newValue: newU, functionResult: uResult});\r\n                }\r\n            }\r\n        }\r\n        f1Node = simplify(parse(`(${functionTexts[0]}) u + (${functionTexts[1]}) y + (${functionTexts[2]})`));\r\n        f2Node = simplify(parse(`(${functionTexts[0]}) u + (${functionTexts[1]}) y`));\r\n        generateResults(results1, f1Node, [initialVector[1], 0]);\r\n        generateResults(results2, f2Node, [0, 1]);\r\n\r\n        // Final Y\r\n        const factor = (initialVector[3] - results1.y[iterations - 1].newValue) / results2.y[iterations - 1].newValue;\r\n        for (let i = 0; i < iterations; i++) {\r\n            results.push({\r\n                currentX: (i === 0) ? initialVector[0] : xArray[i - 1],\r\n                newX: xArray[i],\r\n                currentY: (i === 0) ? initialVector[1] : results[i - 1].newY,\r\n                newY: results1.y[i].newValue + factor * results2.y[i].newValue\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatexs, solverType, initialVector, iterations, stepSize, f1Node, f2Node, xArray, results1, results2, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`y^{''} = p(x)y^{'} + q(x)y + r(x)`} />.\r\n                    </Typography>\r\n                    <Divider />\r\n                    <Grid className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Typography variant=\"h6\">\r\n                            Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                        </Typography>\r\n                        <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event)=>setSolverType(event.target.value)}>\r\n                            <FormControlLabel value=\"euler\" control={<Radio />} label=\"Euler\" />\r\n                            <FormControlLabel value=\"runge\" control={<Radio />} label=\"Runge-Kutta\" />\r\n                        </RadioGroup>\r\n                    </Grid>\r\n                    <Grid xs item className=\"functions-display\">\r\n                        <Box border={1} borderRadius={5} boxShadow={2}>\r\n                            <Collapse in={!hasError}>\r\n                                {!functionsError && <Fade triggerOnce>\r\n                                <TeX math={String.raw`y^{''} = (${functionLatexs[0]}) y^{'} + (${functionLatexs[1]}) y + (${functionLatexs[2]})`} block />\r\n                                </Fade>}\r\n                            </Collapse>\r\n                        </Box>\r\n                    </Grid>\r\n                    <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`p(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[0]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(0, mathField.text());\r\n                                            setSpecificFunctionLatex(0, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[0]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[0]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`q(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[1]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(1, mathField.text());\r\n                                            setSpecificFunctionLatex(1, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[1]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[1]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`r(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[2]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(2, mathField.text());\r\n                                            setSpecificFunctionLatex(2, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[2]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[2]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                                <Collapse in={intervalError}>\r\n                                    <Alert severity=\"error\">\r\n                                        {intervalErrorText}\r\n                                    </Alert>\r\n                                </Collapse>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    const initialVector = params.initialVector;\r\n    const xArray = params.xArray;\r\n    const currentX = (currentIteration === 1) ? initialVector[0] : xArray[currentIteration - 2];\r\n    const newX = xArray[currentIteration - 1];\r\n    const results1 = params.results1;\r\n    const results2 = params.results2;\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& ${formatLatex(params.stepSize)}\r\n        \\\\\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(newX)}\r\n        \\end{array}\r\n        \\\\\r\n        `;\r\n        const generateResultsLatex = (index, resultsArray, node, initialValues) => {\r\n            latexContent += String.raw`\r\n            \\\\ \\hline\r\n            \\\\ \\text{First we find the solution to } y_${index} \\text{ whereby}\r\n            \\\\ y^{''}_{${index}} = u^{'} = ${mathjsToLatex(node)}\r\n            \\\\ \\text{with the initial values: } y_{${index}}(${initialVector[0]}) = ${initialValues[0]} \\text{ and } y_{${index}}^{'}(${initialVector[0]}) = ${initialValues[1]}\r\n            `;\r\n            const currentYResult = resultsArray.y[currentIteration - 1];\r\n            const currentUResult = resultsArray.u[currentIteration - 1];\r\n            const currentY = (currentIteration === 1) ? initialValues[0] : resultsArray.y[currentIteration - 2].newValue;\r\n            const currentU = (currentIteration === 1) ? initialValues[1] : resultsArray.u[currentIteration - 2].newValue;\r\n            const newY = currentYResult.newValue;\r\n            const newU = currentUResult.newValue;\r\n\r\n            if (params.solverType === 'runge') {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ x_{${currentIteration - 1}} &=& ${formatLatex(currentX)}\r\n                \\\\ y_{${currentIteration - 1}} &=& ${formatLatex(currentY)}\r\n                \\\\ u_{${currentIteration - 1}} &=& ${formatLatex(currentU)}\r\n                \\\\\r\n                \\\\ k_{1y} &=& u_{${currentIteration - 1}}\r\n                \\\\        &=& ${formatLatex(currentYResult.k1)}\r\n                \\\\\r\n                \\\\ k_{1u} &=& u^{'} ( x_{${currentIteration - 1}}, y_{${currentIteration - 1}}, u_{${currentIteration - 1}} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k1)}\r\n                \\\\\r\n                \\\\ k_{2y} &=& u_{${currentIteration - 1}} + \\frac{h}{2} k_{1u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k2)}\r\n                \\\\\r\n                \\\\ k_{2u} &=& u^{'} ( x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + \\frac{h}{2} k_{1y}, u_{${currentIteration - 1}} + \\frac{h}{2} k_{1u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k2)}\r\n                \\\\\r\n                \\\\ k_{3y} &=& u_{${currentIteration - 1}} + \\frac{h}{2} k_{2u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k3)}\r\n                \\\\\r\n                \\\\ k_{3u} &=& u^{'} ( x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + \\frac{h}{2} k_{2y}, u_{${currentIteration - 1}} + \\frac{h}{2} k_{2u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k3)}\r\n                \\\\\r\n                \\\\ k_{4y} &=& u_{${currentIteration - 1}} + h k_{3u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k4)}\r\n                \\\\\r\n                \\\\ k_{4u} &=& u^{'} ( x_{${currentIteration - 1}} + h, , u_{${currentIteration - 1}} + h k_{3u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k4)}\r\n                \\\\\r\n                \\\\ y^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1y} + 2 k_{2y} + 2 k_{3y} + k_{4y} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(newY)}\r\n                \\\\\r\n                \\\\ u^{${index}}_{${currentIteration}} &=& u_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1u} + 2 k_{2u} + 2 k_{3u} + k_{4u} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(newU)}\r\n                \\end{array}\r\n                \\\\\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ x_{${currentIteration - 1}} &=& ${formatLatex(currentX)}\r\n                \\\\ y_{${currentIteration - 1}} &=& ${formatLatex(currentY)}\r\n                \\\\ u_{${currentIteration - 1}} &=& ${formatLatex(currentU)}\r\n                \\\\\r\n                \\\\ y^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot u_{${currentIteration - 1}}\r\n                \\\\                                    &=& ${formatLatex(newY)}\r\n                \\\\\r\n                \\\\ u^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot u^{'} ( x_{${currentIteration - 1}}, y_{${currentIteration - 1}}, u_{${currentIteration - 1}} )\r\n                \\\\                                    &=& ${formatLatex(newU)}\r\n                \\end{array}\r\n                \\\\\r\n                `;\r\n            }\r\n        }\r\n        generateResultsLatex(\"A\", results1, params.f1Node, [initialVector[1], 0]);\r\n        generateResultsLatex(\"B\", results2, params.f2Node, [0, 1]);\r\n\r\n        // Final Y\r\n        latexContent += String.raw`\r\n        \\\\ \\hline\r\n        \\\\ \\text{Finally,}\r\n        \\\\ \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y^{A}_{${currentIteration}} + \\frac{y(b) - y^{A}_{${params.iterations}}}{y^{B}_{${params.iterations}}} y^{B}_{${currentIteration}}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(results1.y[currentIteration - 1].newValue)} + \\frac{${formatLatex(initialVector[3])} - ${formatLatex(results1.y[params.iterations - 1].newValue)} } {${formatLatex(results2.y[params.iterations - 1].newValue)}} ( ${formatLatex(results2.y[currentIteration - 1].newValue)} )\r\n        \\\\\r\n        \\\\                         &=& \\colorbox{aqua}{\\bf{${formatLatex(params.results[currentIteration - 1].newY)}}}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\\\ \\text{Note: } y_{${currentIteration}} \\text{ can only be computed after } y^{A} \\text{ and } y^{B} \\text{ are computed for } ${initialVector[0]} < x < ${initialVector[2]}\r\n        \\\\ \\text{in order to obtain } y^{A}_{${params.iterations}} \\text{ and }  y^{B}_{${params.iterations}}\r\n        `;\r\n\r\n        latexContent += String.raw`\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation={\"horizontal\"}\r\n                                    onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeShooting;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js",["232"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\index.js",[],["233","234"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\NotFound.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js",["235"],"import {isValidMath, mathjsToLatex, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".derivative-input\",\r\n        title: \"Derivative\",\r\n        content:\r\n            \"The function's derivative will be shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Newton's method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearNewton({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    // Another sample would be: `3x^2+2x-8`\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue, derivValue, derivLatex;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        derivValue = derivative(functionText, 'x');\r\n        derivLatex = mathjsToLatex(derivValue);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(0.0);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX: results[i - 1].newX;\r\n            let funcResult, derivResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({x : previousX});\r\n                derivResult = derivValue.evaluate({x : previousX});\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            \r\n            let newX = previousX - funcResult / derivResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                derivResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, iterations, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"derivative-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Derivative:\r\n                                    </Typography>\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                    <Collapse in={!functionError}>\r\n                                        {!functionError && <Fade triggerOnce><TeX math={derivLatex} block /></Fade>}\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"initialX-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial value, <TeX math={String.raw`x_0`} />:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setInitialX(parseFloat(event.target.value))}\r\n                                        error={initialXError}\r\n                                        label={initialXError?\"Error\":\"\"}\r\n                                        defaultValue={initialX.toString()}\r\n                                        helperText={initialXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f'(${previousXLatex}) &=& ${formatLatex(currentResult.derivResult)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{f(${previousXLatex})}{f'(${previousXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex});\r\n            calculator.current.setExpression({ id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${currentResult.derivResult}` });\r\n            calculator.current.setExpression({ id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel:true, latex:\r\n                `(${currentResult.previousX}, ${currentResult.funcResult})` });\r\n            calculator.current.setExpression({ id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel:true, latex:\r\n                `(${currentResult.newX}, 0)` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearNewton;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js",["236"],"import {formatMatrixLatex} from \"../../utils\";\r\nimport {initialMatrix4 as initialMatrix, generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { identity, column as getColumn, lup, usolve, lsolve, multiply, transpose } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n        \"Increase/Reduce the matrix's size\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n        \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearInverse({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n            }\r\n            setGridState({columns, rows});\r\n        };\r\n    }\r\n\r\n    // Solve\r\n    let solve = true;\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const matrixSize = gridState.rows.length;\r\n    let iterations = matrixSize;\r\n    const lupResult = lup(originalMatrix);\r\n    let lowerMatrix = lupResult.L;\r\n    let upperMatrix = lupResult.U;\r\n    let permutation = lupResult.p;\r\n    let identityMatrix = identity(matrixSize);\r\n    let inverseMatrix = [];\r\n    let results = [];\r\n    let inverseError = false;\r\n    for (let iter  = 0; iter < iterations; iter++) {\r\n        let identityColumn = getColumn(identityMatrix, iter).toArray();\r\n        let d, dError = false, x, xError = false;\r\n        try {\r\n            d = lsolve(lowerMatrix, identityColumn).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            dError = true;\r\n        }\r\n        try {\r\n            x = usolve(upperMatrix, d).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            xError = true;\r\n        }\r\n        inverseMatrix.push(x);\r\n        results.push({\r\n            identityColumn,\r\n            d,\r\n            dError,\r\n            x,\r\n            xError,\r\n        });\r\n        if (dError || xError) {\r\n            inverseError = true;\r\n            iterations = iter + 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!inverseError) {\r\n        inverseMatrix = transpose(inverseMatrix);\r\n        inverseMatrix = permutation.map(i => inverseMatrix[i]);\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {originalMatrix, matrixSize, lowerMatrix, upperMatrix, iterations, results, inverseMatrix};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        \r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"h6\">\r\n                                                Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                            </Typography>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                            </IconButton>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                <AddCircleOutlineOutlinedIcon />\r\n                                            </IconButton>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Matrix, A:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={0} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={gridState.columns}\r\n                                                        rowGetter={i => gridState.rows[i]}\r\n                                                        rowsCount={gridState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </Grid>                                    \r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({smallScreen, params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let latexContent;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}`;\r\n        if (currentIteration === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\text{After LU decomposition,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A &=& L U\r\n            \\\\\r\n            \\\\   &=& ${matrixToLatex(params.lowerMatrix)} ${matrixToLatex(params.lowerMatrix)}\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            `\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\ I_{${currentIteration}} = ${matrixToLatex(currentResult.identityColumn, {single: true})}\r\n        \\\\\r\n        \\\\ \\text{Using backsubstitution,}\r\n        \\\\ \\begin{array}{rcl}\r\n         L d &=& I_{${currentIteration}}\r\n        \\\\\r\n        \\\\ ${matrixToLatex(params.lowerMatrix)} d &=& ${matrixToLatex(currentResult.identityColumn, {single: true})}\r\n        \\\\`\r\n        if (!currentResult.dError) {\r\n            latexContent += String.raw`\r\n            \\\\ d &=& ${matrixToLatex(currentResult.d, {single: true})}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Using backsubstitution again,}\r\n            \\\\ \\begin{array}{rcl}\r\n            U x &=& d\r\n            \\\\\r\n            \\\\ ${matrixToLatex(params.upperMatrix)} x &=& ${matrixToLatex(currentResult.d, {single: true})}\r\n            \\\\\r\n            `;\r\n            if (!currentResult.xError) {\r\n                latexContent += String.raw`\r\n                \\\\ x &=& ${matrixToLatex(currentResult.x, {single: true})}\r\n                \\\\ \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ A^{-1}_{${currentIteration}} = x = ${matrixToLatex(currentResult.x, {single: true})}\r\n\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\end{array}\r\n                \\\\ \\text{Given that x cannot be solved,}\r\n                \\\\ \\text{an inverse does not exist.}\r\n                \\\\\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\ \\end{array}\r\n            \\\\ \\text{Given that d cannot be solved,}\r\n            \\\\ \\text{an inverse does not exist.}\r\n            \\\\\r\n            `;\r\n        }\r\n        \r\n        if (currentIteration === params.iterations && !currentResult.dError && !currentResult.xError) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\\r\n            \\\\ Inverse, A^{-1} = ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\ \\text{To verify the answer,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A A^{-1} &=& ${matrixToLatex(params.originalMatrix)} ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex(multiply(params.originalMatrix, params.inverseMatrix))}\r\n            \\\\\r\n            \\\\                           &=&  \\text{Identity Matrix}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\\r\n            `\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n    }\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                <Grid xs item className=\"iteration-slider\">\r\n                    <Slide direction=\"left\" triggerOnce>\r\n                        <Box id=\"iteration-slider\" width=\"70vw\">\r\n                            <Slider\r\n                                orientation=\"horizontal\"\r\n                                onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                defaultValue={1}\r\n                                aria-labelledby=\"discrete-slider-small-steps\"\r\n                                step={1}\r\n                                marks\r\n                                min={1}\r\n                                max={params.iterations<=0 ? 1 :params.iterations}\r\n                                valueLabelDisplay=\"on\"\r\n                            />\r\n                        </Box>\r\n                    </Slide>\r\n                </Grid>\r\n                <Grid xs item className=\"step-math\">\r\n                    <Slide direction=\"right\" triggerOnce>\r\n                        <Card className={styleClasses.card}>\r\n                            <CardContent className={styleClasses.cardContent}>\r\n                                <Typography variant=\"h6\">\r\n                                    Iteration {currentIteration}:\r\n                                </Typography>\r\n                                <TeX math={latexContent} block />\r\n                            </CardContent>\r\n                        </Card>\r\n                    </Slide>\r\n                </Grid>\r\n            </Grid>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearInverse;",["237","238"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\matrix_utils.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\App.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js",["239"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js",["240"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the fixed point method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearFixedPoint({methodName, markdown}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\frac{3-x^3}{6}`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(1.5);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX: results[i - 1].newX;\r\n            let funcResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({x : previousX});\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            \r\n            let newX = funcResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, iterations, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        It is assumed that the user has already rearranged the original function into the form\r\n                        <TeX math={String.raw`\\ x=f(x)`} />\r\n                        .\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, f(x):\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"initialX-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial value, <TeX math={String.raw`x_0`} />:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setInitialX(parseFloat(event.target.value))}\r\n                                        error={initialXError}\r\n                                        label={initialXError?\"Error\":\"\"}\r\n                                        defaultValue={initialX.toString()}\r\n                                        helperText={initialXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ ${newXLatex} &=& f(${previousXLatex})\r\n        \\\\              &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex});\r\n            calculator.current.setExpression({ id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel:true, latex:\r\n                `(${currentResult.previousX}, ${currentResult.funcResult})` });\r\n            calculator.current.setExpression({ id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel:true, latex:\r\n                `(${currentResult.newX}, 0)` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearFixedPoint;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\MethodInfo.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\Graph.js",["241"],"import {React, useState, useRef, useEffect, useCallback } from \"react\";\r\nimport Button from '@material-ui/core/Button';\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport MuiDialogTitle from '@material-ui/core/DialogTitle';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport TimelineIcon from '@material-ui/icons/Timeline';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\nimport * as Desmos from 'desmos';\r\nimport { Fade } from \"react-awesome-reveal\";\r\n\r\nimport { withStyles } from '@material-ui/core/styles';\r\nconst styleClasses = (theme) => ({\r\n    root: {\r\n        margin: 0,\r\n        padding: theme.spacing(2),\r\n    },\r\n    closeButton: {\r\n        position: 'absolute',\r\n        right: theme.spacing(1),\r\n        top: theme.spacing(1),\r\n        color: theme.palette.grey[500],\r\n    },\r\n});\r\n\r\nconst DialogTitle = withStyles(styleClasses)((props) => {\r\n    const { children, classes, onClose, ...other } = props;\r\n    return (\r\n      <MuiDialogTitle disableTypography className={classes.root} {...other}>\r\n        {onClose ? (\r\n          <IconButton aria-label=\"close\" className={classes.closeButton} onClick={onClose}>\r\n            <CloseIcon />\r\n          </IconButton>\r\n        ) : null}\r\n      </MuiDialogTitle>\r\n    );\r\n});\r\n\r\nconst DialogContent =  withStyles((theme) => ({\r\n    root: {\r\n        padding: theme.spacing(2),\r\n    },\r\n}))((props) => {\r\n    const params = props.params;\r\n    const [currentIteration, setCurrentIteration] = useState(params.currentIteration);\r\n    const defaultIteration = params.currentIteration;\r\n    const currentResult = params.iterations > 0 ? params.results[currentIteration - 1] : null;\r\n    const desmosDiv = useRef(null);\r\n    const calculator = useRef(null);\r\n\r\n    const updateGraph = useCallback(() => {\r\n        if (calculator.current){\r\n            calculator.current.updateSettings({xAxisLabel: 'x', yAxisLabel: 'y',  xAxisArrowMode: Desmos.AxisArrowModes.POSITIVE, yAxisArrowMode: Desmos.AxisArrowModes.POSITIVE });\r\n            params.graphCallback(calculator, currentResult, currentIteration);\r\n        }\r\n    }, [calculator, currentResult, params, currentIteration]);\r\n    updateGraph();\r\n\r\n    useEffect(() => {\r\n        if (desmosDiv.current){\r\n            const smallScreen = props.smallScreen;\r\n            desmosDiv.current.style.width = smallScreen?'90vw':'60vw';\r\n            desmosDiv.current.style.height = smallScreen?'90vh':'60vh';\r\n            const desmosOptions = {\r\n                keypad: false,\r\n                expressions: false,\r\n                expressionsTopbar: false,\r\n            };\r\n            calculator.current = Desmos.GraphingCalculator(desmosDiv.current, desmosOptions);\r\n            updateGraph();\r\n        }\r\n    }, []);\r\n\r\n    return (\r\n        \r\n        <Grid container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n            {params.description && <Box component=\"div\" overflow=\"visible\">\r\n                    <Typography variant=\"h6\">\r\n                        {params.description}\r\n                    </Typography>\r\n                </Box>\r\n            }\r\n            {params.functionLatex && <Box component=\"div\" overflow=\"visible\">\r\n                    <TeX math={`${params.functionLatex}`} block />\r\n                </Box>\r\n            }\r\n            <Typography variant=\"h6\">\r\n                {params.iterations > 0 ? `Iteration ${currentIteration}:` : <br />}\r\n            </Typography>\r\n            {params.iterations > 0 &&\r\n                <Box width=\"70%\">\r\n                    <Slider\r\n                        orientation=\"horizontal\"\r\n                        onChange={(event, value) => setCurrentIteration(value)}\r\n                        defaultValue={defaultIteration}\r\n                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                        step={1}\r\n                        marks\r\n                        min={1}\r\n                        max={params.iterations}\r\n                        valueLabelDisplay=\"auto\"\r\n                    />\r\n                </Box>\r\n            }\r\n            <Grid item>\r\n                <div ref={desmosDiv}>\r\n                </div>\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n});\r\n\r\nfunction Graph({params, smallScreen}) {\r\n    const [openDialog, setOpenDialog] = useState(false);\r\n\r\n    const handleClickOpen = () => {\r\n        setOpenDialog(true);\r\n    };\r\n      const handleClose = () => {\r\n        setOpenDialog(false);\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Button variant=\"contained\" color=\"primary\" endIcon={<TimelineIcon/>} onClick={handleClickOpen}>\r\n                View Graph\r\n            </Button>\r\n            \r\n            <Dialog scroll='paper' maxWidth={false} fullScreen={smallScreen} onClose={handleClose} aria-labelledby=\"customized-dialog-title\" open={openDialog}>\r\n                <Fade>\r\n                    <DialogTitle id=\"customized-dialog-title\" onClose={handleClose} />\r\n                    <DialogContent dividers smallScreen={smallScreen} params={params} />\r\n                </Fade>\r\n            </Dialog>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Graph;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\MethodType.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js",["242"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\ErrorBoundary.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\header\\Header.js",["243"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\utils.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Menu.js",[],{"ruleId":"244","replacedBy":"245"},{"ruleId":"246","replacedBy":"247"},{"ruleId":"244","replacedBy":"248"},{"ruleId":"246","replacedBy":"249"},{"ruleId":"244","replacedBy":"250"},{"ruleId":"246","replacedBy":"251"},{"ruleId":"244","replacedBy":"252"},{"ruleId":"246","replacedBy":"253"},{"ruleId":"254","severity":1,"message":"255","line":118,"column":21,"nodeType":"256","messageId":"257","endLine":118,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":133,"column":21,"nodeType":"256","messageId":"257","endLine":133,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":136,"column":21,"nodeType":"256","messageId":"257","endLine":136,"endColumn":45},{"ruleId":"258","severity":1,"message":"259","line":82,"column":11,"nodeType":"260","messageId":"261","endLine":82,"endColumn":22},{"ruleId":"244","replacedBy":"262"},{"ruleId":"246","replacedBy":"263"},{"ruleId":"254","severity":1,"message":"255","line":197,"column":25,"nodeType":"256","messageId":"257","endLine":197,"endColumn":46},{"ruleId":"254","severity":1,"message":"255","line":118,"column":21,"nodeType":"256","messageId":"257","endLine":118,"endColumn":42},{"ruleId":"258","severity":1,"message":"264","line":3,"column":37,"nodeType":"260","messageId":"261","endLine":3,"endColumn":44},{"ruleId":"254","severity":1,"message":"255","line":112,"column":21,"nodeType":"256","messageId":"257","endLine":112,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":116,"column":21,"nodeType":"256","messageId":"257","endLine":116,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":125,"column":21,"nodeType":"256","messageId":"257","endLine":125,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":117,"column":21,"nodeType":"256","messageId":"257","endLine":117,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":116,"column":21,"nodeType":"256","messageId":"257","endLine":116,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":116,"column":21,"nodeType":"256","messageId":"257","endLine":116,"endColumn":42},{"ruleId":"244","replacedBy":"265"},{"ruleId":"246","replacedBy":"266"},{"ruleId":"258","severity":1,"message":"267","line":12,"column":8,"nodeType":"260","messageId":"261","endLine":12,"endColumn":12},{"ruleId":"268","severity":1,"message":"269","line":238,"column":57,"nodeType":"270","messageId":"271","endLine":238,"endColumn":83},{"ruleId":"268","severity":1,"message":"272","line":242,"column":53,"nodeType":"270","messageId":"271","endLine":242,"endColumn":79},{"ruleId":"258","severity":1,"message":"273","line":6,"column":31,"nodeType":"260","messageId":"261","endLine":6,"endColumn":39},{"ruleId":"254","severity":1,"message":"255","line":129,"column":21,"nodeType":"256","messageId":"257","endLine":129,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":139,"column":21,"nodeType":"256","messageId":"257","endLine":139,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":138,"column":25,"nodeType":"256","messageId":"257","endLine":138,"endColumn":46},{"ruleId":"254","severity":1,"message":"255","line":128,"column":21,"nodeType":"256","messageId":"257","endLine":128,"endColumn":42},{"ruleId":"254","severity":1,"message":"255","line":157,"column":25,"nodeType":"256","messageId":"257","endLine":157,"endColumn":46},{"ruleId":"254","severity":1,"message":"255","line":134,"column":21,"nodeType":"256","messageId":"257","endLine":134,"endColumn":42},{"ruleId":"244","replacedBy":"274"},{"ruleId":"246","replacedBy":"275"},{"ruleId":"254","severity":1,"message":"255","line":139,"column":21,"nodeType":"256","messageId":"257","endLine":139,"endColumn":42},{"ruleId":"258","severity":1,"message":"276","line":1,"column":9,"nodeType":"260","messageId":"261","endLine":1,"endColumn":26},{"ruleId":"244","replacedBy":"277"},{"ruleId":"246","replacedBy":"278"},{"ruleId":"258","severity":1,"message":"259","line":82,"column":11,"nodeType":"260","messageId":"261","endLine":82,"endColumn":22},{"ruleId":"254","severity":1,"message":"255","line":130,"column":21,"nodeType":"256","messageId":"257","endLine":130,"endColumn":42},{"ruleId":"279","severity":1,"message":"280","line":77,"column":8,"nodeType":"281","endLine":77,"endColumn":10,"suggestions":"282"},{"ruleId":"254","severity":1,"message":"255","line":118,"column":21,"nodeType":"256","messageId":"257","endLine":118,"endColumn":42},{"ruleId":"258","severity":1,"message":"283","line":1,"column":8,"nodeType":"260","messageId":"261","endLine":1,"endColumn":14},"no-native-reassign",["284"],"no-negated-in-lhs",["285"],["284"],["285"],["284"],["285"],["284"],["285"],"no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-unused-vars","'smallScreen' is assigned a value but never used.","Identifier","unusedVar",["284"],["285"],"'useMemo' is defined but never used.",["284"],["285"],"'Link' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'modifiedMatrix'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'modifiedOutput'.","'identity' is defined but never used.",["284"],["285"],"'formatMatrixLatex' is defined but never used.",["284"],["285"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'props.smallScreen' and 'updateGraph'. Either include them or remove the dependency array.","ArrayExpression",["286"],"'styles' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"287","fix":"288"},"Update the dependencies array to be: [props.smallScreen, updateGraph]",{"range":"289","text":"290"},[2998,3000],"[props.smallScreen, updateGraph]"]