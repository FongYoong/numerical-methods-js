[{"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\App.js":"1","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\index.js":"2","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\MethodType.js":"3","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Menu.js":"4","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\header\\Header.js":"5","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\constants\\categories.js":"6","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Category.js":"7","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js":"8","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js":"9","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js":"10","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js":"11","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js":"12","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js":"13","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js":"14","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js":"15","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js":"16","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js":"17","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js":"18","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js":"19","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js":"20","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js":"21","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js":"22","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js":"23","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js":"24","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js":"25","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Predictor.js":"26","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js":"27","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js":"28","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\NotFound.js":"29","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\utils.js":"30","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\reportWebVitals.js":"31","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js":"32","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js":"33","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js":"34","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js":"35","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js":"36","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\QR.js":"37","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js":"38","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\matrix_utils.js":"39","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js":"40","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\Graph.js":"41","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js":"42","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js":"43","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\System.js":"44","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js":"45","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js":"46","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\MethodInfo.js":"47"},{"size":3906,"mtime":1614874498674,"results":"48","hashOfConfig":"49"},{"size":1020,"mtime":1614579888854,"results":"50","hashOfConfig":"49"},{"size":1642,"mtime":1613731632402,"results":"51","hashOfConfig":"49"},{"size":1846,"mtime":1613730935548,"results":"52","hashOfConfig":"49"},{"size":4343,"mtime":1614873901388,"results":"53","hashOfConfig":"49"},{"size":10553,"mtime":1614875985762,"results":"54","hashOfConfig":"49"},{"size":1516,"mtime":1613730966207,"results":"55","hashOfConfig":"49"},{"size":17676,"mtime":1614853120811,"results":"56","hashOfConfig":"49"},{"size":18899,"mtime":1614853226311,"results":"57","hashOfConfig":"49"},{"size":16640,"mtime":1614175250017,"results":"58","hashOfConfig":"49"},{"size":16376,"mtime":1614875949534,"results":"59","hashOfConfig":"49"},{"size":23619,"mtime":1614147155955,"results":"60","hashOfConfig":"49"},{"size":16985,"mtime":1614852315487,"results":"61","hashOfConfig":"49"},{"size":25360,"mtime":1614680223686,"results":"62","hashOfConfig":"49"},{"size":18151,"mtime":1614606848806,"results":"63","hashOfConfig":"49"},{"size":23686,"mtime":1614872648436,"results":"64","hashOfConfig":"49"},{"size":17249,"mtime":1614608253952,"results":"65","hashOfConfig":"49"},{"size":23116,"mtime":1614175454161,"results":"66","hashOfConfig":"49"},{"size":21632,"mtime":1614175433275,"results":"67","hashOfConfig":"49"},{"size":25329,"mtime":1614175516961,"results":"68","hashOfConfig":"49"},{"size":17304,"mtime":1614608201782,"results":"69","hashOfConfig":"49"},{"size":18595,"mtime":1614608169210,"results":"70","hashOfConfig":"49"},{"size":16782,"mtime":1614608112869,"results":"71","hashOfConfig":"49"},{"size":19800,"mtime":1614147259862,"results":"72","hashOfConfig":"49"},{"size":21943,"mtime":1614683567228,"results":"73","hashOfConfig":"49"},{"size":137,"mtime":1612925211319,"results":"74","hashOfConfig":"49"},{"size":20768,"mtime":1614593310164,"results":"75","hashOfConfig":"49"},{"size":3899,"mtime":1614855713251,"results":"76","hashOfConfig":"49"},{"size":151,"mtime":1612927063731,"results":"77","hashOfConfig":"49"},{"size":1896,"mtime":1614851748722,"results":"78","hashOfConfig":"49"},{"size":362,"mtime":1612347361340,"results":"79","hashOfConfig":"49"},{"size":23979,"mtime":1614874703885,"results":"80","hashOfConfig":"49"},{"size":18193,"mtime":1614852370516,"results":"81","hashOfConfig":"49"},{"size":22726,"mtime":1614853541415,"results":"82","hashOfConfig":"49"},{"size":26286,"mtime":1614612745364,"results":"83","hashOfConfig":"49"},{"size":35417,"mtime":1614853360986,"results":"84","hashOfConfig":"49"},{"size":18446,"mtime":1614175194847,"results":"85","hashOfConfig":"49"},{"size":19306,"mtime":1614608122862,"results":"86","hashOfConfig":"49"},{"size":17495,"mtime":1614849591149,"results":"87","hashOfConfig":"49"},{"size":13718,"mtime":1614172217616,"results":"88","hashOfConfig":"49"},{"size":5367,"mtime":1614673874691,"results":"89","hashOfConfig":"49"},{"size":3927,"mtime":1614855726280,"results":"90","hashOfConfig":"49"},{"size":23157,"mtime":1614593650527,"results":"91","hashOfConfig":"49"},{"size":34654,"mtime":1614854256352,"results":"92","hashOfConfig":"49"},{"size":32251,"mtime":1614796624962,"results":"93","hashOfConfig":"49"},{"size":23402,"mtime":1614842541375,"results":"94","hashOfConfig":"49"},{"size":1278,"mtime":1614876045728,"results":"95","hashOfConfig":"49"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1mhuixq",{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"100"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"103"},{"filePath":"104","messages":"105","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"106"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"110"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"100"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117","usedDeprecatedRules":"118"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"121","messages":"122","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123","usedDeprecatedRules":"110"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"126","messages":"127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"128"},{"filePath":"129","messages":"130","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"131","messages":"132","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"133","usedDeprecatedRules":"134"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"137","usedDeprecatedRules":"118"},{"filePath":"138","messages":"139","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"140","messages":"141","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"142","messages":"143","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"118"},{"filePath":"144","messages":"145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"134"},{"filePath":"146","messages":"147","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"110"},{"filePath":"148","messages":"149","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"150","messages":"151","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"152","usedDeprecatedRules":"153"},{"filePath":"154","messages":"155","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"106"},{"filePath":"158","messages":"159","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"160","usedDeprecatedRules":"110"},{"filePath":"161","messages":"162","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"163"},{"filePath":"164","messages":"165","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"166","usedDeprecatedRules":"100"},{"filePath":"167","messages":"168","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"118"},{"filePath":"171","messages":"172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"173","messages":"174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"134"},{"filePath":"175","messages":"176","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"177","messages":"178","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"179","messages":"180","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"181","messages":"182","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"183","usedDeprecatedRules":"100"},{"filePath":"184","messages":"185","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"186","messages":"187","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"188"},{"filePath":"189","messages":"190","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"191","messages":"192","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"193","messages":"194","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"106"},{"filePath":"195","messages":"196","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"197"},{"filePath":"198","messages":"199","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"200","usedDeprecatedRules":"110"},{"filePath":"201","messages":"202","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"203","usedDeprecatedRules":"118"},{"filePath":"204","messages":"205","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"206","usedDeprecatedRules":"118"},{"filePath":"207","messages":"208","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"209","messages":"210","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211","usedDeprecatedRules":"153"},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\App.js",["214"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\index.js",[],["215","216"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\MethodType.js",[],["217","218"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Menu.js",[],["219","220"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\header\\Header.js",["221"],"import styles from './Header.module.css';\r\nimport MethodInfo from '../MethodInfo';\r\nimport React from \"react\";\r\nimport { makeStyles, withStyles } from '@material-ui/core/styles';\r\nimport AppBar from '@material-ui/core/AppBar';\r\nimport Toolbar from '@material-ui/core/Toolbar';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport MuiDialogTitle from '@material-ui/core/DialogTitle';\r\nimport MuiDialogContent from '@material-ui/core/DialogContent';\r\nimport Slide from '@material-ui/core/Slide';\r\n\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport HomeIcon from '@material-ui/icons/Home';\r\nimport GitHubIcon from '@material-ui/icons/GitHub';\r\nimport InfoIcon from '@material-ui/icons/Info';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\n\r\nimport { Link } from \"react-router-dom\";\r\nimport { Fade } from \"react-awesome-reveal\";\r\nimport {generatePath} from \"../utils\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n    root: {\r\n        flexGrow: 1,\r\n    },\r\n    homeButton: {\r\n      marginRight: theme.spacing(0),\r\n    },\r\n    githubButton: {\r\n        marginRight: theme.spacing(0),\r\n    },\r\n    infoButton: {\r\n        marginRight: theme.spacing(0),\r\n    },\r\n}));\r\n\r\nconst dialogStyles = (theme) => ({\r\n    root: {\r\n        margin: 0,\r\n        padding: theme.spacing(2),\r\n    },\r\n    closeButton: {\r\n        position: 'absolute',\r\n        right: theme.spacing(1),\r\n        top: theme.spacing(1),\r\n        color: theme.palette.grey[500],\r\n    },\r\n});\r\n\r\nconst Transition = React.forwardRef(function Transition(props, ref) {\r\n  return <Slide direction=\"up\" ref={ref} {...props} />;\r\n});\r\nconst DialogTitle = withStyles(dialogStyles)((props) => {\r\n    const { children, classes, onClose, ...other } = props;\r\n    return (\r\n      <MuiDialogTitle disableTypography className={classes.root} {...other}>\r\n        <Typography variant=\"h6\">{children}</Typography>\r\n        {onClose ? (\r\n          <IconButton aria-label=\"close\" className={classes.closeButton} onClick={onClose}>\r\n            <CloseIcon />\r\n          </IconButton>\r\n        ) : null}\r\n      </MuiDialogTitle>\r\n    );\r\n});\r\n\r\nconst DialogContent = withStyles((theme) => ({\r\n  root: {\r\n    overflow: 'visible',\r\n    padding: theme.spacing(2),\r\n  },\r\n}))(MuiDialogContent);\r\n\r\nfunction Header({methodName, markdown}) {\r\n    const styleClasses = useStyles();\r\n\r\n    let title = methodName? methodName:\"Numerical Methods\";\r\n\r\n    const [dialogOpen, setDialogOpen] = React.useState(false);\r\n    const handleOpenInfoDialog = () => {\r\n        setDialogOpen(true);\r\n    };\r\n\r\n    const handleCloseInfoDialog = () => {\r\n        setDialogOpen(false);\r\n    };\r\n\r\n    return (\r\n        <div className={styleClasses.root}>\r\n            <AppBar position=\"fixed\">\r\n                <Toolbar>\r\n                    <IconButton rel=\"noopener noreferrer\" href=\"https://github.com/FongYoong/numerical-methods-js\" target=\"_blank\" edge=\"start\" className={styleClasses.githubButton} color=\"inherit\" aria-label=\"GitHub\">\r\n                        <GitHubIcon />\r\n                    </IconButton>\r\n                    <IconButton component={Link} to={generatePath()} edge=\"start\" className={styleClasses.homeButton} color=\"inherit\" aria-label=\"Home\">\r\n                        <HomeIcon />\r\n                    </IconButton>\r\n                    {methodName &&\r\n                        <IconButton onClick={handleOpenInfoDialog} className={styleClasses.infoButton} edge=\"start\" color=\"inherit\" aria-label=\"Info\">\r\n                            <InfoIcon />\r\n                        </IconButton>\r\n                    }\r\n                    <Fade>\r\n                        <Typography variant=\"h6\" className={styleClasses.title}>\r\n                            {title}\r\n                        </Typography>\r\n                    </Fade>\r\n                </Toolbar>\r\n            </AppBar>\r\n            <Toolbar />\r\n            <Dialog open={dialogOpen} onClose={handleCloseInfoDialog} TransitionComponent={Transition}>\r\n                <DialogTitle onClose={handleCloseInfoDialog}>\r\n                    Info\r\n                </DialogTitle>\r\n                <DialogContent dividers>\r\n                    <MethodInfo markdown={markdown} />\r\n                </DialogContent>\r\n            </Dialog>\r\n        </div>\r\n    );\r\n}\r\nexport default Header;",["222","223"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\constants\\categories.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\menu\\Category.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js",["224"],"import {isValidMath, mathjsToLatex, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".derivative-input\",\r\n        title: \"Derivative\",\r\n        content:\r\n            \"The function's derivative will be shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Newton's method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearNewton({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    // Another sample would be: `3x^2+2x-8`\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue, derivValue, derivLatex;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        derivValue = derivative(functionText, 'x');\r\n        derivLatex = mathjsToLatex(derivValue);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(0.0);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX: results[i - 1].newX;\r\n            let funcResult, derivResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({x : previousX});\r\n                derivResult = derivValue.evaluate({x : previousX});\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            \r\n            let newX = previousX - funcResult / derivResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                derivResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, iterations, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"derivative-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Derivative:\r\n                                    </Typography>\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                    <Collapse in={!functionError}>\r\n                                        {!functionError && <Fade triggerOnce><TeX math={derivLatex} block /></Fade>}\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"initialX-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial value, <TeX math={String.raw`x_0`} />:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setInitialX(parseFloat(event.target.value))}\r\n                                        error={initialXError}\r\n                                        label={initialXError?\"Error\":\"\"}\r\n                                        defaultValue={initialX.toString()}\r\n                                        helperText={initialXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f'(${previousXLatex}) &=& ${formatLatex(currentResult.derivResult)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{f(${previousXLatex})}{f'(${previousXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex});\r\n            calculator.current.setExpression({ id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${currentResult.derivResult}` });\r\n            calculator.current.setExpression({ id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel:true, latex:\r\n                `(${currentResult.previousX}, ${currentResult.funcResult})` });\r\n            calculator.current.setExpression({ id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel:true, latex:\r\n                `(${currentResult.newX}, 0)` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearNewton;",["225","226"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js",["227"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js",["228"],"import {formatMatrixLatex} from \"../../utils\";\r\nimport {initialMatrix4 as initialMatrix, generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { identity, column as getColumn, lup, usolve, lsolve, multiply, transpose } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n        \"Increase/Reduce the matrix's size\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n        \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearInverse({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n            }\r\n            setGridState({columns, rows});\r\n        };\r\n    }\r\n\r\n    // Solve\r\n    let solve = true;\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const matrixSize = gridState.rows.length;\r\n    let iterations = matrixSize;\r\n    const lupResult = lup(originalMatrix);\r\n    let lowerMatrix = lupResult.L;\r\n    let upperMatrix = lupResult.U;\r\n    let permutation = lupResult.p;\r\n    let identityMatrix = identity(matrixSize);\r\n    let inverseMatrix = [];\r\n    let results = [];\r\n    let inverseError = false;\r\n    for (let iter  = 0; iter < iterations; iter++) {\r\n        let identityColumn = getColumn(identityMatrix, iter).toArray();\r\n        let d, dError = false, x, xError = false;\r\n        try {\r\n            d = lsolve(lowerMatrix, identityColumn).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            dError = true;\r\n        }\r\n        try {\r\n            x = usolve(upperMatrix, d).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            xError = true;\r\n        }\r\n        inverseMatrix.push(x);\r\n        results.push({\r\n            identityColumn,\r\n            d,\r\n            dError,\r\n            x,\r\n            xError,\r\n        });\r\n        if (dError || xError) {\r\n            inverseError = true;\r\n            iterations = iter + 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!inverseError) {\r\n        inverseMatrix = transpose(inverseMatrix);\r\n        inverseMatrix = permutation.map(i => inverseMatrix[i]);\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {originalMatrix, matrixSize, lowerMatrix, upperMatrix, iterations, results, inverseMatrix};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        \r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                            <Typography variant=\"h6\">\r\n                                                Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                            </Typography>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                            </IconButton>\r\n                                            <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                <AddCircleOutlineOutlinedIcon />\r\n                                            </IconButton>\r\n                                        </Grid>\r\n                                        <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item>\r\n                                                <Typography variant=\"h6\">\r\n                                                    Matrix, A:\r\n                                                </Typography>\r\n                                            </Grid>\r\n                                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid key={0} item className={styleClasses.overflow}>\r\n                                                    <ReactDataGrid\r\n                                                        columns={gridState.columns}\r\n                                                        rowGetter={i => gridState.rows[i]}\r\n                                                        rowsCount={gridState.rows.length}\r\n                                                        onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                        enableCellSelect={true}\r\n                                                        headerRowHeight={1}\r\n                                                        minColumnWidth={columnWidth}\r\n                                                        minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                        rowHeight={rowHeight}\r\n                                                        minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                    />\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </Grid>                                    \r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({smallScreen, params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let latexContent;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}`;\r\n        if (currentIteration === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\text{After LU decomposition,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A &=& L U\r\n            \\\\\r\n            \\\\   &=& ${matrixToLatex(params.lowerMatrix)} ${matrixToLatex(params.lowerMatrix)}\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            `\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\ I_{${currentIteration}} = ${matrixToLatex(currentResult.identityColumn, {single: true})}\r\n        \\\\\r\n        \\\\ \\text{Using backsubstitution,}\r\n        \\\\ \\begin{array}{rcl}\r\n         L d &=& I_{${currentIteration}}\r\n        \\\\\r\n        \\\\ ${matrixToLatex(params.lowerMatrix)} d &=& ${matrixToLatex(currentResult.identityColumn, {single: true})}\r\n        \\\\`\r\n        if (!currentResult.dError) {\r\n            latexContent += String.raw`\r\n            \\\\ d &=& ${matrixToLatex(currentResult.d, {single: true})}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Using backsubstitution again,}\r\n            \\\\ \\begin{array}{rcl}\r\n            U x &=& d\r\n            \\\\\r\n            \\\\ ${matrixToLatex(params.upperMatrix)} x &=& ${matrixToLatex(currentResult.d, {single: true})}\r\n            \\\\\r\n            `;\r\n            if (!currentResult.xError) {\r\n                latexContent += String.raw`\r\n                \\\\ x &=& ${matrixToLatex(currentResult.x, {single: true})}\r\n                \\\\ \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ A^{-1}_{${currentIteration}} = x = ${matrixToLatex(currentResult.x, {single: true})}\r\n\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\end{array}\r\n                \\\\ \\text{Given that x cannot be solved,}\r\n                \\\\ \\text{an inverse does not exist.}\r\n                \\\\\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\ \\end{array}\r\n            \\\\ \\text{Given that d cannot be solved,}\r\n            \\\\ \\text{an inverse does not exist.}\r\n            \\\\\r\n            `;\r\n        }\r\n        \r\n        if (currentIteration === params.iterations && !currentResult.dError && !currentResult.xError) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\\r\n            \\\\ Inverse, A^{-1} = ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\ \\text{To verify the answer,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A A^{-1} &=& ${matrixToLatex(params.originalMatrix)} ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex(multiply(params.originalMatrix, params.inverseMatrix))}\r\n            \\\\\r\n            \\\\                           &=&  \\text{Identity Matrix}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\\r\n            `\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n    }\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                <Grid xs item className=\"iteration-slider\">\r\n                    <Slide direction=\"left\" triggerOnce>\r\n                        <Box id=\"iteration-slider\" width=\"70vw\">\r\n                            <Slider\r\n                                orientation=\"horizontal\"\r\n                                onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                defaultValue={1}\r\n                                aria-labelledby=\"discrete-slider-small-steps\"\r\n                                step={1}\r\n                                marks\r\n                                min={1}\r\n                                max={params.iterations<=0 ? 1 :params.iterations}\r\n                                valueLabelDisplay=\"on\"\r\n                            />\r\n                        </Box>\r\n                    </Slide>\r\n                </Grid>\r\n                <Grid xs item className=\"step-math\">\r\n                    <Slide direction=\"right\" triggerOnce>\r\n                        <Card className={styleClasses.card}>\r\n                            <CardContent className={styleClasses.cardContent}>\r\n                                <Typography variant=\"h6\">\r\n                                    Iteration {currentIteration}:\r\n                                </Typography>\r\n                                <TeX math={latexContent} block />\r\n                            </CardContent>\r\n                        </Card>\r\n                    </Slide>\r\n                </Grid>\r\n            </Grid>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearInverse;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js",["229"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js",[],["230","231"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js",["232"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeMultistep({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.2);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let initialYValues = [initialVector[1]];\r\n    let rungeResults = [];\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let i = 1; i <= 3; i++) {\r\n            // Runge-Kutta for the first 4 y values\r\n            const currentX = (i === 1) ? initialVector[0] : rungeResults[i - 2].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = initialYValues[i - 1];\r\n            const k1 = functionNode.evaluate({x: currentX, y: currentY});\r\n            const k2 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k1 * stepHalf});\r\n            const k3 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k2 * stepHalf});\r\n            const k4 = functionNode.evaluate({x: currentX + stepSize, y: currentY + k3 * stepSize});\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            initialYValues.push(newY);\r\n            rungeResults.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] + stepSize * 3 : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            let yValues;\r\n            if (iter < 4) {\r\n                yValues = [...initialYValues.slice(iter, 4), ...results.slice(0, iter).map((v)=>v.newY)];\r\n            }\r\n            else {\r\n                yValues = results.slice(iter - 4, iter).map((v)=>v.newY);\r\n            }\r\n            const f3 = functionNode.evaluate({x: currentX, y: yValues[3]});\r\n            const f2 = functionNode.evaluate({x: currentX - stepSize, y: yValues[2]});\r\n            const f1 = functionNode.evaluate({x: currentX - 2 * stepSize, y: yValues[1]});\r\n            const f0 = functionNode.evaluate({x: currentX - 3 * stepSize, y: yValues[0]});\r\n            const tempY = yValues[3] + stepSize / 24 * (55 * f3 - 59 * f2 + 37 * f1 - 9 * f0);\r\n            const fTemp = functionNode.evaluate({x: newX, y: tempY});\r\n            const newY = yValues[3] + stepSize / 24 * (9 * fTemp + 19 * f3 - 5 * f2 + f1);\r\n            results.push({\r\n                currentX,\r\n                yValues,\r\n                newX,\r\n                newY,\r\n                tempY,\r\n                fTemp,\r\n                f3,\r\n                f2,\r\n                f1,\r\n                f0,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, initialVector, stepSize, iterations, initialYValues, rungeResults, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\`;\r\n        if (currentIteration === 1) {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{First, we apply 4th order Runge-Kutta to obtain } y_{0}, y_{-1}, \\text{ and } y_{-2}:\r\n            \\end{array}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ x_{-3} &=& ${params.rungeResults[0].currentX}, \\\\ y_{-3} &=& ${params.rungeResults[0].currentY}`;\r\n            for (let i = 1; i <= 3; i++) {\r\n                const currentRungeResult = params.rungeResults[i - 1];\r\n                // Runge-Kutta for the first 4 y values\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ x_{${i - 3}} &=& ${formatLatex(currentRungeResult.newX)}, \\\\ y_{${i - 3}} &=& y_{${i - 4}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n                \\\\\r\n                \\\\              &=& ${formatLatex(currentRungeResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentRungeResult.k1)} + 2 (${formatLatex(currentRungeResult.k2)}) + 2 (${formatLatex(currentRungeResult.k3)}) + ${formatLatex(currentRungeResult.k4)} )\r\n                \\\\\r\n                \\\\              &=& ${formatLatex(currentRungeResult.newY)}`;\r\n            }\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Now, we can initiate the Adams-Moulton method.}`;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}}^{*} &=& y_{${currentIteration - 1}} + \\frac{h}{24} ( 55 f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n                                                                                        - 59 f(x_{${currentIteration - 2}}, y_{${currentIteration - 2}})\r\n                                                                                        + 37 f(x_{${currentIteration - 3}}, y_{${currentIteration - 3}})\r\n                                                                                        - 9 f(x_{${currentIteration - 4}}, y_{${currentIteration - 4}}) )\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.yValues[3])} + \\frac{${formatLatex(params.stepSize)}}{24} [ 55 (${formatLatex(currentResult.f3)})\r\n                                                                                                           - 59 (${formatLatex(currentResult.f2)})\r\n                                                                                                           + 37 (${formatLatex(currentResult.f1)})\r\n                                                                                                           - 9 (${formatLatex(currentResult.f0)}) ]\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.tempY)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{24} ( 9 f(x_{${currentIteration}}, y_{${currentIteration}}^{*})\r\n                                                                                    + 19 f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n                                                                                    - 5 f(x_{${currentIteration - 2}}, y_{${currentIteration - 2}})\r\n                                                                                    + 1 f(x_{${currentIteration - 3}}, y_{${currentIteration - 3}}) )\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.yValues[3])} + \\frac{${formatLatex(params.stepSize)}}{24} [ 9 (${formatLatex(currentResult.fTemp)})\r\n                                                                                                    + 19 (${formatLatex(currentResult.f3)})\r\n                                                                                                    - 5 (${formatLatex(currentResult.f2)})\r\n                                                                                                    + 1 (${formatLatex(currentResult.f1)}) ]\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < 3; i++) {\r\n                const r = params.rungeResults[i];\r\n                calculator.current.setExpression({ id: \"Runge\"+i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.currentX}, ${r.currentY})` });\r\n            }\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.yValues[3]})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            const currentY = currentResult.yValues[3];\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeMultistep;",["233","234"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js",["235"],"import {isValidMath, mathjsKeywords, mathjsToLatex, formatLatex} from \"../../utils\";\r\nimport {getBinomialCoefficient} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useMemo} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".x-input\",\r\n        title: \"X value\",\r\n        content:\r\n            \"Specify the value of x at which to evaluate.\",\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the differential order to evaluate.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction DiffFinite({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3x^5+2x^3-8`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // x values\r\n    const [xInput, setXInput] = useState(1.5);\r\n    let xInputError = false;\r\n    let xInputErrorText = \"\";\r\n    if (isNaN(xInput)) {\r\n        xInputError = true;\r\n        xInputErrorText = \"x value cannot be empty!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 14) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! Due to the factorial nature of the finite difference, the browser will lag or crash if it attempts to compute this.\";\r\n    }\r\n\r\n    // Step Size\r\n    const [stepSize, setStepSize] = useState(0.01);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize) || stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size cannot be negative or zero!\";\r\n    }\r\n\r\n    let hasError = functionError || xInputError || orderError || stepSizeError;\r\n\r\n    const derivValue = useMemo(() => {\r\n        let d = derivative(functionValue, 'x');\r\n        for (let i = 0; i < order - 1; i++) {\r\n            d = derivative(d, 'x');\r\n        }\r\n        return d;\r\n    }, [functionValue, order]);\r\n\r\n    // Solve\r\n    let latexContent;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n\r\n        const evaluateFunction = (forward, offset) => {\r\n            const step = offset * stepSize ;\r\n            return forward ? functionValue.evaluate({x : xInput + step}) : functionValue.evaluate({x : xInput - step});\r\n        }\r\n\r\n        const denominator = Math.pow(stepSize, order);\r\n        let forwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n        }\r\n        let backwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n        }\r\n        let centralDiff = 0;\r\n        if (order > 1) {\r\n            for (let i = 0; i <= order; i++) {\r\n                centralDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(true, order/2 - i) / denominator;\r\n            }\r\n        }\r\n        else {\r\n            // To adhere to lecturer's annoying convention\r\n            centralDiff = (evaluateFunction(true, 1) - evaluateFunction(false, 1)) / (2 * stepSize);\r\n        }\r\n\r\n        const correctDerivative = derivValue.evaluate({x : xInput});\r\n\r\n        const forwardError = Math.abs(correctDerivative - forwardDiff);\r\n        const backwardError = Math.abs(correctDerivative - backwardDiff);\r\n        const centralError = Math.abs(correctDerivative - centralDiff);\r\n        \r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f^{${order}}(x) &=& ${mathjsToLatex(derivValue)}\r\n        \\\\                 &=& ${formatLatex(correctDerivative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Forward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{${order}-i} \\dbinom{${order}}{i} f(x+ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            //forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, order - i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, i))}) ${i===order? '':'+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(forwardDiff)}\r\n        \\end{array}\r\n        `;\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Backward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x-ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            // backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(false, i))}) ${i===order? '':'+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(backwardDiff)}\r\n        \\end{array}\r\n        `;\r\n\r\n        if (order === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{2h} [f(x+h) - f(x-h)]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(2*stepSize)}} [${formatLatex(evaluateFunction(true, 1))} - ${formatLatex(evaluateFunction(false, 1))} ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{h^{${order}}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x+(\\frac{n}{2}-i)h) \\right]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(stepSize)}^{${order}}} [\r\n            `;\r\n            for (let i = 0; i <= order; i++) {\r\n                latexContent += String.raw`\r\n                (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, order/2 - i))}) ${i===order? '':'+'}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Percentage Error} &=& |Actual - Estimate|\r\n        \\\\\r\n        \\\\ E_{Forward} &=& ${formatLatex(forwardError)}\r\n        \\\\ E_{Backward} &=& ${formatLatex(backwardError)}\r\n        \\\\ E_{Central} &=& ${formatLatex(centralError)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                    \r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"x-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        x:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setXInput(parseFloat(event.target.value))}\r\n                                        error={xInputError}\r\n                                        label={xInputError?\"Error\":\"\"}\r\n                                        defaultValue={xInput.toString()}\r\n                                        helperText={xInputErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"order-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Order:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setOrder(parseInt(event.target.value))}\r\n                                        error={orderError}\r\n                                        label={orderError?\"Error\":\"\"}\r\n                                        defaultValue={order.toString()}\r\n                                        helperText={orderErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                        <Container className={styleClasses.container}>\r\n                            <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item className=\"step-math\">\r\n                                    <Slide direction=\"left\" triggerOnce>\r\n                                        <Card className={styleClasses.card}>\r\n                                            <CardContent className={styleClasses.cardContent}>\r\n                                                <TeX math={latexContent} block />\r\n                                            </CardContent>\r\n                                        </Card>\r\n                                    </Slide>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffFinite;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js",["236"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js",["237"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js",["238"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js",["239"],"import {isValidMath, mathjsKeywords, formatLatex} from \"../../utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N, which must be even.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralSimpson({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n    else if (subIntervals % 2 !== 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be an even integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({x : x});\r\n            if (i === 0 || i === subIntervals){\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                if (i % 2 === 0){\r\n                    integralResult += 2 * f;\r\n                    results.push(2 * f);\r\n                }\r\n                else {\r\n                    integralResult += 4 * f;\r\n                    results.push(4 * f);\r\n                }\r\n            }\r\n        }\r\n        integralResult *= width / 3;\r\n        \r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{3} [f(x_0) + 4 \\sum_{i=1, odd}^{${subIntervals - 1}} f(x_i) + 2 \\sum_{j=2, even}^{${subIntervals - 2}} f(x_j) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            let coefficient = \"\";\r\n            if (i > 0 && i < subIntervals){\r\n                if (i % 2 === 0){\r\n                    coefficient = \"2\";\r\n                }\r\n                else {\r\n                    coefficient = \"4\";\r\n                }\r\n            }\r\n            latexContent += String.raw`${coefficient}f(${formatLatex(lowerX + i * width)}) ${i===subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i===subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\"+functionLatex});\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\"+lowerX});\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\"+upperX});\r\n            calculator.current.setExpression({ id: 'n', latex: \"n=\"+subIntervals});\r\n            calculator.current.setExpression({ id: 'g', latex: String.raw`g\\left(x\\right)=f\\left(x\\right)\\left\\{a\\le x\\le b\\right\\}`});\r\n            calculator.current.setExpression({ id: 'shade', color: Desmos.Colors.BLACK, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,g\\left(x\\right)\\right)\\le y\\le\\max\\left(0,g\\left(x\\right)\\right)`});\r\n            calculator.current.setExpression({ id: 'i', latex: String.raw`i=\\left[1...n\\right]`});\r\n            calculator.current.setExpression({ id: 'sOdd', latex: String.raw`S_{i3}=\\left[2,4,...n\\right]`});\r\n            calculator.current.setExpression({ id: 'x1', latex: String.raw`x_{1}=a+\\left(S_{i3}-2\\right)\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'x2', latex: String.raw`x_{2}=a+\\left(S_{i3}-1\\right)\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'x3', latex: String.raw`x_{3}=a+S_{i3}\\frac{b-a}{n}`});\r\n            calculator.current.setExpression({ id: 'simpsonShade', color: Desmos.Colors.RED, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,P\\left(x\\right)\\right)\\le y\\le\\max\\left(0,P\\left(x\\right)\\right)\\left\\{x_{1}\\le x\\le x_{3}\\right\\}`});\r\n            calculator.current.setExpression({ id: 'xLine1', color: Desmos.Colors.RED, latex: String.raw`x=a+\\left(i-1\\right)\\frac{b-a}{n}\\left\\{\\min\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\le y\\le\\max\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\right\\}`});\r\n            calculator.current.setExpression({ id: 'xLine2', color: Desmos.Colors.RED, latex: String.raw`x=b\\left\\{\\min\\left(0,f\\left(b\\right)\\right)\\le y\\le\\max\\left(0,f\\left(b\\right)\\right)\\right\\}`});\r\n            calculator.current.setExpression({ id: 'sn', latex: String.raw`S_{n}=\\frac{1}{3}\\cdot\\frac{b-a}{n}\\left(f\\left(a\\right)+\\sum_{t=1}^{\\frac{n}{2}}4f\\left(a+\\left(2t-1\\right)\\frac{b-a}{n}\\right)+\\sum_{t=1}^{\\frac{n}{2}-1}2f\\left(a+2t\\frac{b-a}{n}\\right)+f\\left(b\\right)\\right)`});\r\n            calculator.current.setExpression({ id: 'p', latex: String.raw`P\\left(x\\right)=f\\left(x_{1}\\right)\\cdot\\frac{x-x_{2}}{x_{1}-x_{2}}\\cdot\\frac{x-x_{3}}{x_{1}-x_{3}}+f\\left(x_{2}\\right)\\cdot\\frac{x-x_{1}}{x_{2}-x_{1}}\\cdot\\frac{x-x_{3}}{x_{2}-x_{3}}+f\\left(x_{3}\\right)\\cdot\\frac{x-x_{1}}{x_{3}-x_{1}}\\cdot\\frac{x-x_{2}}{x_{3}-x_{2}}\\left\\{x_{1}\\le x\\le x_{3}\\right\\}`});\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        If even subintervals, 2nd order polynomial/parabola.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"subIntervals-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Subintervals, N:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setSubIntervals(parseInt(event.target.value))}\r\n                                        error={subIntervalsError}\r\n                                        label={subIntervalsError?\"Error\":\"\"}\r\n                                        defaultValue={subIntervals.toString()}\r\n                                        helperText={subIntervalsErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Lower x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setLowerX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={lowerX.toString()}\r\n                                        helperText={lowerXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Upper x value:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setUpperX(parseFloat(event.target.value))}\r\n                                        error={intervalError}\r\n                                        label={intervalError?\"Error\":\"\"}\r\n                                        defaultValue={upperX.toString()}\r\n                                        helperText={upperXErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                        <Container className={styleClasses.container}>\r\n                            <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item className=\"step-math\">\r\n                                    <Slide direction=\"left\" triggerOnce>\r\n                                        <Card className={styleClasses.card}>\r\n                                            <CardContent className={styleClasses.cardContent}>\r\n                                                <TeX math={latexContent} block />\r\n                                            </CardContent>\r\n                                        </Card>\r\n                                    </Slide>\r\n                                </Grid>\r\n                                <Grid xs item className=\"graph-button\">\r\n                                    <Slide direction=\"right\" triggerOnce>\r\n                                        <Graph params={{iterations: 0, functionLatex, graphCallback, smallScreen}} />\r\n                                    </Slide>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralSimpson;",["240","241"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js",["242"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js",["243"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".heun-input\",\r\n        title: \"Heun's method\",\r\n        content:\r\n        \"If checked, Heun's method will be used instead of the default Euler's method.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Euler's method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeEuler({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Heun mode\r\n    const [heunMode, setHeunMode] = useState(true);\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const functionResult = functionNode.evaluate({x: currentX, y: currentY});\r\n            let functionResultHeun, tempY;\r\n            let newY = currentY + stepSize * functionResult;\r\n            if (heunMode) {\r\n                functionResultHeun = functionNode.evaluate({x: newX, y: newY});\r\n                tempY = newY;\r\n                newY = currentY + stepSize / 2 * (functionResult + functionResultHeun);\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                tempY,\r\n                functionResult,\r\n                functionResultHeun\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, heunMode, initialVector, stepSize, iterations, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"heun-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <FormControlLabel\r\n                                control={<Checkbox checked={heunMode} onChange={(event) => setHeunMode(event.target.checked)} name=\"heunMode\" />}\r\n                                label=\"Use Heun's Method\"\r\n                            />\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        `;\r\n\r\n        if (params.heunMode) {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}}^{*} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.tempY)}\r\n            \\end{array}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{2} ( f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}}) + f(x_{${currentIteration}}, y_{${currentIteration}}^{*}) )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${formatLatex(params.stepSize)}}{2} ( ${formatLatex(currentResult.functionResult)} + ${formatLatex(currentResult.functionResultHeun)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeEuler;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Predictor.js",[],["244","245"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js",["246"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeRunge({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const k1 = functionNode.evaluate({x: currentX, y: currentY});\r\n            const k2 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k1 * stepHalf});\r\n            const k3 = functionNode.evaluate({x: currentX + stepHalf, y: currentY + k2 * stepHalf});\r\n            const k4 = functionNode.evaluate({x: currentX + stepSize, y: currentY + k3 * stepSize});\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, initialVector, stepSize, iterations, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ k_1 &=& f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n        \\\\    &=& ${formatLatex(currentResult.k1)}\r\n        \\\\\r\n        \\\\ k_2 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_1 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k2)}\r\n        \\\\\r\n        \\\\ k_3 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_2 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k3)}\r\n        \\\\\r\n        \\\\ k_4 &=& f(x_{${currentIteration - 1}} + h, y_{${currentIteration - 1}} + k_1 \\cdot h)\r\n        \\\\    &=& ${formatLatex(currentResult.k4)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array} \\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeRunge;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js",["247"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\NotFound.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\utils.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\reportWebVitals.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js",["248"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js",["249"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js",["250"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js",["251"],"import {isValidMath, mathjsToLatex, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix17, generateGridCallback, createNewColumn, gridTo2DArray, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative, simplify, subtract, norm } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function with multiple variables. Variable names must contain only one alphabet, such as x, y, z etc.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".variables-display\",\r\n        title: \"Variables\",\r\n        content:\r\n        \"The variables of the function are displayed here.\",\r\n    },\r\n    {\r\n        target: \".vector-input\",\r\n        title: \"Initial Vector\",\r\n        content:\r\n        \"Specify the initial values of the variables here.\",\r\n    },\r\n    {\r\n        target: \".initialRoot-input\",\r\n        title: \"Initial Root Guess\",\r\n        content:\r\n            \"Specify the initial root guess when finding the root.\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold when finding the root.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the gradient method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OptiGradient({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    // 2xy+2x-x^2-2y^2\r\n    // 2\\left(x+y\\right)^2 + \\left(x-y\\right)^2 + 3x + 2y\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`2\\left(x+y\\right)^2 + \\left(x-y\\right)^2 + 3x + 2y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name.length > 1) {\r\n                    throw \"variableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Variable names must contain only one alphabet! x, y, z etc\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    \r\n    let [vectorState, setVectorState] = useState(initialMatrix17);\r\n\r\n    let initialVector = { columns:[], rows:[{}] };\r\n    const addVariableToVector = (variableName, variableValue) => {\r\n        const columns = initialVector.columns;\r\n        const rows = initialVector.rows;\r\n        columns.push(createNewColumn(columns.length, variableName));\r\n        let colName = `col_${columns.length}`;\r\n        rows[0][colName] = vectorState.rows[0].hasOwnProperty(colName) ?  vectorState.rows[0][colName] : variableValue;\r\n    }\r\n    for (let v of variables) {\r\n        addVariableToVector(v, 0);\r\n    }\r\n    vectorState = initialVector;\r\n\r\n    // Initial Root\r\n    const [initialRoot, setInitialRoot] = useState(0.1);\r\n    let initialRootError = false;\r\n    let initialRootErrorText = \"\";\r\n    if (isNaN(initialRoot)) {\r\n        initialRootError = true;\r\n        initialRootErrorText = \"Initial root guess must be a valid number!\";\r\n    }\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.005);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (errorThreshold < 0 || isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative or zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(5);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || initialRootError || thresholdError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let derivNodes = {};\r\n    let results = [];\r\n\r\n    console.log(functionText);\r\n\r\n    if (isValidMath(functionNode) && !hasError && variables.length > 0) {\r\n        solve = true;\r\n        for (let v of variables) {\r\n            derivNodes[v] = derivative(functionText, v);\r\n        }\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const previousVector = (iter === 0) ? gridTo2DArray(vectorState.rows)[0]: results[iter - 1].newVector;\r\n            let derivScope = {};\r\n            variables.forEach((element, index) => {\r\n                derivScope[element] = previousVector[index];\r\n            });\r\n            let derivResult = [];\r\n            for (let v of variables) {\r\n                derivResult.push(derivNodes[v].evaluate(derivScope));\r\n            }\r\n            let directionNodes = {};\r\n            variables.forEach((element, index) => {\r\n                directionNodes[element] = simplify(parse(String.raw`${previousVector[index]} + t*(${derivResult[index]})`));\r\n            });\r\n            const transformedFunction = functionNode.transform(function (node, path, parent) {\r\n                if (node.isSymbolNode && !mathjsKeywords.includes(node.name)) {\r\n                    return directionNodes[node.name];\r\n                }\r\n                else {\r\n                    return node;\r\n                }\r\n            });\r\n            const simplifiedFunction = simplify(transformedFunction);\r\n            const simplifiedFunctionDeriv = derivative(simplifiedFunction, 't');\r\n            const simplifiedFunctionDeriv2 = derivative(simplifiedFunctionDeriv, 't');\r\n            let rootT = initialRoot;\r\n            let newtonIter = 1;\r\n            while(true) {\r\n                const oldT = rootT;\r\n                const funcValue = simplifiedFunctionDeriv.evaluate({t: rootT});\r\n                const derivValue = simplifiedFunctionDeriv2.evaluate({t: rootT});\r\n                rootT = rootT - funcValue / derivValue;\r\n                if (!isFinite(rootT)) {\r\n                    break;\r\n                }\r\n                let errorX = Math.abs(rootT - oldT);\r\n                if (errorX < errorThreshold || newtonIter > 50) {\r\n                    break;\r\n                }\r\n                newtonIter++;\r\n            }\r\n            const newVector = variables.map((element, index) => {\r\n                return directionNodes[element].evaluate({t: rootT});\r\n            });\r\n            let functionScope = {};\r\n            variables.forEach((element, index) => {\r\n                functionScope[element] = newVector[index];\r\n            });\r\n            const newFunctionResult = functionNode.evaluate(functionScope)\r\n            const errorMagnitude = norm(subtract(newVector, previousVector), 2);\r\n            results.push({\r\n                previousVector,\r\n                derivResult,\r\n                directionNodes,\r\n                transformedFunction,\r\n                simplifiedFunction,\r\n                simplifiedFunctionDeriv,\r\n                newtonIter,\r\n                rootT,\r\n                newVector,\r\n                newFunctionResult,\r\n                errorMagnitude,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionNode, variables, derivNodes, initialRoot, errorThreshold, iterations, results};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                        }}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"variables-display\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Variables:\r\n                                    </Typography>\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                    <Collapse in={!functionError}>\r\n                                        {!functionError && <Fade triggerOnce>\r\n                                            <Typography variant=\"h6\">\r\n                                                {[...variables].join(', ')}\r\n                                            </Typography>\r\n                                        </Fade>}\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"vector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Point, <TeX math={String.raw`X^{(0)}`} />:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialRoot-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial root guess, <TeX math={String.raw`t_0`} />:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setInitialRoot(parseFloat(event.target.value))}\r\n                                        error={initialRootError}\r\n                                        label={initialRootError?\"Error\":\"\"}\r\n                                        defaultValue={initialRoot.toString()}\r\n                                        helperText={initialRootErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"errorThreshold-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Error threshold for root finding:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setErrorThreshold(parseFloat(event.target.value))}\r\n                                        error={thresholdError}\r\n                                        label={thresholdError?\"Error\":\"\"}\r\n                                        defaultValue={errorThreshold.toString()}\r\n                                        helperText={thresholdErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations of gradient method:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({smallScreen, params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    const results = params.results;\r\n    const variables = params.variables;\r\n    const currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        \r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f(${variables.join(\",\")}) = ${mathjsToLatex(params.functionNode)}\r\n        \\\\\r\n        \\\\ X^{(${currentIteration - 1})} = ${matrixToLatex([currentResult.previousVector])}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}`;\r\n\r\n        variables.forEach((v, index) => {\r\n            latexContent += String.raw`\r\n            \\\\ f_${v} &=& ${mathjsToLatex(params.derivNodes[v])}\r\n            \\\\ f_${v}(X^{(${currentIteration - 1})}) &=& ${formatLatex(currentResult.derivResult[index])}\r\n            \\\\ \r\n            `;\r\n        });\r\n\r\n        latexContent += String.raw`\r\n        \\\\ \\nabla f &=& ${matrixToLatex([currentResult.derivResult])}\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ X^{(${currentIteration})} &=& X^{(${currentIteration - 1})} + t \\cdot \\nabla f\r\n        \\\\\r\n        \\\\                           &=& ${matrixToLatex([currentResult.previousVector])} + t \\cdot ${matrixToLatex([currentResult.derivResult])}\r\n        \\\\\r\n        \\\\                           &=& \\left[\\begin{matrix}\r\n        `;\r\n        variables.forEach((v, index) => {\r\n            latexContent += String.raw`\r\n            ${mathjsToLatex(currentResult.directionNodes[v])}\r\n            `;\r\n            if (index !== variables.length - 1) {\r\n                latexContent += ',&';\r\n            }\r\n        });\r\n        latexContent += String.raw`\r\n        \\end{matrix}\\right]\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ f(X^{(${currentIteration})}) &=& ${mathjsToLatex(currentResult.transformedFunction)}\r\n        \\\\\r\n        \\\\                              &=& ${mathjsToLatex(currentResult.simplifiedFunction)}\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\frac{df(X^{(${currentIteration})})}{dt} = 0\r\n        \\\\\r\n        \\\\ ${mathjsToLatex(currentResult.simplifiedFunctionDeriv)} &=& 0\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        `\r\n        if (!isFinite(currentResult.rootT)) {\r\n            latexContent += String.raw`\r\n            \\\\ \\text{Given that }\\frac{df(X^{(${currentIteration})})}{dt} = 0 \\text{ has no roots, the gradient method cannot proceed.}\r\n            `;\r\n        }\r\n        else {    \r\n            latexContent += String.raw`\r\n            \\\\ \\text{Using the Newton-Rhapson method}\r\n            \\\\ \\text{with initial guess } t_0 = ${params.initialRoot}\r\n            \\\\ \\text{and error threshold of ${params.errorThreshold},}\r\n            \\\\ \\text{the solution to } \\frac{df(X^{(${currentIteration})})}{dt} = 0 \\text{ after ${currentResult.newtonIter} iterations is:}\r\n            \\\\\r\n            \\\\ t^* = ${formatLatex(currentResult.rootT)}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ X^{(${currentIteration})} &=& X^{(${currentIteration - 1})} + t^* \\cdot \\nabla f\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex([currentResult.previousVector])} + ${formatLatex(currentResult.rootT)} \\cdot ${matrixToLatex([currentResult.derivResult])}\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex([currentResult.newVector])}\r\n            \\\\\r\n            \\\\ f(X^{(${currentIteration})}) &=& ${formatLatex(currentResult.newFunctionResult)}\r\n            \\\\\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ Error &=& \\lVert X^{(${currentIteration})} - X^{(${currentIteration - 1})} \\rVert\r\n            \\\\       &=& \\lVert ${matrixToLatex([currentResult.newVector])} - ${matrixToLatex([currentResult.previousVector])} \\rVert\r\n            \\\\       &=& ${formatLatex(currentResult.errorMagnitude)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        \\end{array}\r\n        `\r\n    }\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iteration {currentIteration}:\r\n                                    </Typography>\r\n                                    <TeX math={latexContent} block />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OptiGradient;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js",["252","253"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\linear\\QR.js",[],["254","255"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js",["256"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\matrix_utils.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js",[],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\Graph.js",["257"],"import {React, useState, useRef, useEffect, useCallback } from \"react\";\r\nimport Button from '@material-ui/core/Button';\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport MuiDialogTitle from '@material-ui/core/DialogTitle';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport TimelineIcon from '@material-ui/icons/Timeline';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\nimport * as Desmos from 'desmos';\r\nimport { Fade } from \"react-awesome-reveal\";\r\n\r\nimport { withStyles } from '@material-ui/core/styles';\r\nconst styleClasses = (theme) => ({\r\n    root: {\r\n        margin: 0,\r\n        padding: theme.spacing(2),\r\n    },\r\n    closeButton: {\r\n        position: 'absolute',\r\n        right: theme.spacing(1),\r\n        top: theme.spacing(1),\r\n        color: theme.palette.grey[500],\r\n    },\r\n});\r\n\r\nconst DialogTitle = withStyles(styleClasses)((props) => {\r\n    const { children, classes, onClose, ...other } = props;\r\n    return (\r\n      <MuiDialogTitle disableTypography className={classes.root} {...other}>\r\n        {onClose ? (\r\n          <IconButton aria-label=\"close\" className={classes.closeButton} onClick={onClose}>\r\n            <CloseIcon />\r\n          </IconButton>\r\n        ) : null}\r\n      </MuiDialogTitle>\r\n    );\r\n});\r\n\r\nconst DialogContent =  withStyles((theme) => ({\r\n    root: {\r\n        padding: theme.spacing(2),\r\n    },\r\n}))((props) => {\r\n    const params = props.params;\r\n    const [currentIteration, setCurrentIteration] = useState(params.currentIteration);\r\n    const defaultIteration = params.currentIteration;\r\n    const currentResult = params.iterations > 0 ? params.results[currentIteration - 1] : null;\r\n    const desmosDiv = useRef(null);\r\n    const calculator = useRef(null);\r\n\r\n    const updateGraph = useCallback(() => {\r\n        if (calculator.current){\r\n            calculator.current.updateSettings({xAxisLabel: 'x', yAxisLabel: 'y',  xAxisArrowMode: Desmos.AxisArrowModes.POSITIVE, yAxisArrowMode: Desmos.AxisArrowModes.POSITIVE });\r\n            params.graphCallback(calculator, currentResult, currentIteration);\r\n        }\r\n    }, [calculator, currentResult, params, currentIteration]);\r\n    updateGraph();\r\n\r\n    useEffect(() => {\r\n        if (desmosDiv.current){\r\n            const smallScreen = props.smallScreen;\r\n            desmosDiv.current.style.width = smallScreen?'90vw':'60vw';\r\n            desmosDiv.current.style.height = smallScreen?'90vh':'60vh';\r\n            const desmosOptions = {\r\n                keypad: false,\r\n                expressions: false,\r\n                expressionsTopbar: false,\r\n            };\r\n            calculator.current = Desmos.GraphingCalculator(desmosDiv.current, desmosOptions);\r\n            updateGraph();\r\n        }\r\n    }, []);\r\n\r\n    return (\r\n        \r\n        <Grid container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n            {params.description && <Box component=\"div\" overflow=\"visible\">\r\n                    <Typography variant=\"h6\">\r\n                        {params.description}\r\n                    </Typography>\r\n                </Box>\r\n            }\r\n            {params.functionLatex && <Box component=\"div\" overflow=\"visible\">\r\n                    <TeX math={`${params.functionLatex}`} block />\r\n                </Box>\r\n            }\r\n            <Typography variant=\"h6\">\r\n                {params.iterations > 0 ? `Iteration ${currentIteration}:` : <br />}\r\n            </Typography>\r\n            {params.iterations > 0 &&\r\n                <Box width=\"70%\">\r\n                    <Slider\r\n                        orientation=\"horizontal\"\r\n                        onChange={(event, value) => setCurrentIteration(value)}\r\n                        defaultValue={defaultIteration}\r\n                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                        step={1}\r\n                        marks\r\n                        min={1}\r\n                        max={params.iterations}\r\n                        valueLabelDisplay=\"auto\"\r\n                    />\r\n                </Box>\r\n            }\r\n            <Grid item>\r\n                <div ref={desmosDiv}>\r\n                </div>\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n});\r\n\r\nfunction Graph({params, smallScreen}) {\r\n    const [openDialog, setOpenDialog] = useState(false);\r\n\r\n    const handleClickOpen = () => {\r\n        setOpenDialog(true);\r\n    };\r\n      const handleClose = () => {\r\n        setOpenDialog(false);\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Button variant=\"contained\" color=\"primary\" endIcon={<TimelineIcon/>} onClick={handleClickOpen}>\r\n                View Graph\r\n            </Button>\r\n            \r\n            <Dialog scroll='paper' maxWidth={false} fullScreen={smallScreen} onClose={handleClose} aria-labelledby=\"customized-dialog-title\" open={openDialog}>\r\n                <Fade>\r\n                    <DialogTitle id=\"customized-dialog-title\" onClose={handleClose} />\r\n                    <DialogContent dividers smallScreen={smallScreen} params={params} />\r\n                </Fade>\r\n            </Dialog>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Graph;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js",["258"],"import React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport { Zoom } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport haroldImage from '../../../images/harold.jpg';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".main\",\r\n        title: \"Incomplete!\",\r\n        content:\r\n        \"Nothing to see here.\",\r\n        disableBeacon: true,\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(2)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n    harold: {\r\n        height: \"auto\",\r\n        width: \"30vw\",\r\n        \"border-radius\": \"3em\",\r\n        \"box-shadow\": \"0px 8px 6px rgba(34,34,34,0.6)\",\r\n    }\r\n}));\r\n\r\nfunction DiffMultivariable({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n  \r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography className=\"main\" variant=\"body1\">\r\n                        Incomplete! Nothing to see here.\r\n                    </Typography>\r\n                    <Divider />\r\n                    <img className={styleClasses.harold} src={haroldImage} alt=\"Hide the Pain Harold\" />\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n            \r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffMultivariable;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js",["259"],"import {isValidMath, formatLatex, mathjsToLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix19 as initialMatrix, generateGridCallback, gridTo2DArray, numberFactorials} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the maximum differential order.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply this method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeTaylor({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`2xy`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch(e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" :  \"Invalid equation!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 10) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! It is limited to 10! for performance reasons.\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let derivNodes = [functionNode];\r\n    let derivLatex = String.raw`\\displaystyle\r\n    \\begin{array}{l}\r\n    \\\\ y^{'} = ${functionLatex}\r\n    `;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let i = 1; i < order; i++) {\r\n            derivNodes.push(derivative(derivNodes[i - 1], 'x'));\r\n            derivLatex += String.raw`\r\n            \\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(derivNodes[i])}`;\r\n        }\r\n        derivLatex += String.raw`\\end{array}`;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            let newY = currentY;\r\n            let derivResults = [];\r\n            for (let i = 1; i <= order; i++) {\r\n                const result = derivNodes[i - 1].evaluate({x: currentX, y: currentY});\r\n                derivResults.push(result);\r\n                newY += Math.pow(stepSize, i) * result / numberFactorials[i];\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                derivResults,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatex, order, initialVector, stepSize, iterations, derivNodes, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"function-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={functionLatex}\r\n                                        onChange={(mathField) => {\r\n                                            setFunctionText(mathField.text());\r\n                                            setFunctionLatex(mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                            setFunctionText(mathField.text())\r\n                                        }}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"derivative-display\">\r\n                            <Box border={1} borderRadius={5} boxShadow={2}>\r\n                                <Collapse in={functionError}>\r\n                                    <Alert severity=\"error\">\r\n                                        {functionErrorText}\r\n                                    </Alert>\r\n                                </Collapse>\r\n                                <Collapse in={!functionError}>\r\n                                    {!functionError && <Fade triggerOnce>\r\n                                    <TeX math={derivLatex} block />\r\n                                    </Fade>}\r\n                                </Collapse>\r\n                            </Box>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"order-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Order:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setOrder(parseInt(event.target.value))}\r\n                                        error={orderError}\r\n                                        label={orderError?\"Error\":\"\"}\r\n                                        defaultValue={order.toString()}\r\n                                        helperText={orderErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n\r\n        let formulaLatex = String.raw`h y_{${currentIteration - 1}}^{'}`;\r\n        let valuesLatex = String.raw`${params.stepSize} (${formatLatex(currentResult.derivResults[0])})`;\r\n        for (let i = 2; i <= params.order; i++) {\r\n            //derivLatex += String.raw`\\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(params.derivNodes[i])}`;\r\n            formulaLatex += String.raw`+ \\frac{h^{${i}}}{${i}!} y_{${currentIteration - 1}}^{${`'`.repeat(i)}}`;\r\n            valuesLatex += String.raw`+ \\frac{${params.stepSize}^{${i}}}{${numberFactorials[i]}} ( ${formatLatex(currentResult.derivResults[i - 1])} )`;\r\n        }\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + ${formulaLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${valuesLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        latexContent += String.raw`\r\n\r\n\r\n        `;\r\n        latexContent += String.raw`\r\n    \r\n        `\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeTaylor;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\System.js",["260"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix20 as initialMatrix, createNewColumn, generateGridCallback, gridTo2DArray, cloneArray} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst ORDER_NAMES = ['x', 'y', 'u', 'v', 'w', 'z', 'p', 'q', 'r', 's', 't'];\r\nconst ORDER_FUNCTIONS = ['u', '-x u-y'];\r\nconst ORDER_FUNCTIONS_TEXT = ['u', '-x u-y'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order/Number of equations\",\r\n        content:\r\n        \"Specify the number of 1st order differential equations.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n        \"Choose either Euler or Runge-Kutta.\",\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Functions\",\r\n        content:\r\n        \"Type each function containing the relevant variables. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of each variable.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the selected method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeSystem({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Solver mode: Euler or Runge\r\n    const [solverType, setSolverType] = useState('runge');\r\n\r\n    // Order/ Number of equations\r\n    const [order, setOrder] = useState(2);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order < 2) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be 2 or higher.\";\r\n    }\r\n    else if (order > 9) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! A maximum of 9 is allowed for performance reasons.\";\r\n    }\r\n    const orderArray = [...Array(orderError ? 1 : order).keys()];\r\n    const validVariables = ORDER_NAMES.slice(0, order + 1);\r\n\r\n    // Functions\r\n    const [functionLatexs, setFunctionLatexs] = useState(ORDER_FUNCTIONS.slice());\r\n    const [functionTexts, setFunctionTexts] = useState(ORDER_FUNCTIONS_TEXT.slice());\r\n\r\n    const functionLatexsRef= useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef= useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = orderArray.slice().fill(false);\r\n    let functionErrorTexts = orderArray.slice().fill(\"\");\r\n\r\n    for (let i = 0; i < order; i++){\r\n        if (orderError) {\r\n            break;\r\n        }\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (!validVariables.includes(node.name)) {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        catch(e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? `Only ${validVariables.join(',')} variables are allowed.` :  \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Initial values\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    let initialVector = { columns:[], rows:[{}] };\r\n\r\n    if (!orderError) {\r\n        const addVariableToVector = (variableName, variableValue) => {\r\n            const columns = initialVector.columns;\r\n            const rows = initialVector.rows;\r\n            columns.push(createNewColumn(columns.length, variableName));\r\n            let colName = `col_${columns.length}`;\r\n            rows[0][colName] = vectorState.rows[0].hasOwnProperty(colName) ?  vectorState.rows[0][colName] : variableValue;\r\n        }\r\n        for (let i = 0; i <= order; i++) {\r\n            if (i <= 9){\r\n                addVariableToVector(ORDER_NAMES[i], 0);\r\n            }\r\n        }\r\n        vectorState = initialVector;\r\n        initialVector = gridTo2DArray(vectorState.rows)[0];\r\n    }\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = !functionErrors.every((e) => e === false) || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = {x: [], y: []};\r\n    orderArray.forEach((i) => {\r\n        if (i !== 0) {\r\n            results[ORDER_NAMES[i + 1]] = [];\r\n        }\r\n    });\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results.x[iter - 1];\r\n            // Get current values\r\n            for (let k = 0; k < order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentValue = (iter === 0) ? initialVector[k + 1] : results[varName][iter - 1].newValue;\r\n                results[varName].push({\r\n                    currentValue,\r\n                });\r\n            }\r\n            // Find new values\r\n            if (solverType === 'runge') {\r\n                // k1\r\n                const originalScope = {x: currentX};\r\n                validVariables.filter((value, index) => index !== 0).forEach((value, index) => {\r\n                    originalScope[value] = results[value][iter].currentValue;\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k1 = functionNodes[k].evaluate(originalScope);\r\n                    results[varName][iter]['k1'] = k1;\r\n                }\r\n                // k2\r\n                const k2Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf * results[value][iter].k1;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k2 = functionNodes[k].evaluate(k2Scope);\r\n                    results[varName][iter]['k2'] = k2;\r\n                }\r\n                // k3\r\n                const k3Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf * results[value][iter].k2;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k3 = functionNodes[k].evaluate(k3Scope);\r\n                    results[varName][iter]['k3'] = k3;\r\n                }\r\n                // k4\r\n                const k4Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k4Scope[value] = k4Scope[value] + stepSize;\r\n                    }\r\n                    else {\r\n                        k4Scope[value] = k4Scope[value] + stepSize * results[value][iter].k3;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k4 = functionNodes[k].evaluate(k4Scope);\r\n                    results[varName][iter]['k4'] = k4;\r\n                }\r\n\r\n                // Find new values\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const newValue = currentValue + stepSize / 6 * (results[varName][iter]['k1']\r\n                                                                    + 2 * results[varName][iter]['k2']\r\n                                                                    + 2 * results[varName][iter]['k3']\r\n                                                                    + results[varName][iter]['k4']);\r\n                    results[varName][iter] = {...results[varName][iter], newValue};\r\n                }\r\n            }\r\n            else {\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const scope = {x: currentX, [varName]: currentValue};\r\n                    validVariables.filter((value, index) => index !== 0 && index !== k + 1 ).forEach((value, index) => {\r\n                        scope[value] = results[value][iter].currentValue;\r\n                    });\r\n                    const functionResult = functionNodes[k].evaluate(scope);\r\n                    const newValue = currentValue + stepSize * functionResult;\r\n                    results[varName][iter] = {...results[varName][iter], newValue, functionResult};\r\n                }\r\n            }\r\n            const newX = currentX + stepSize;\r\n            results.x.push(newX);\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {functionLatexs, solverType, order, validVariables, initialVector, stepSize, iterations, results, smallScreen};\r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied to 1st order differential equations of the form &nbsp;\r\n                        <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                    </Typography>\r\n                    <Grid container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"order-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Order / Number of equations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setOrder(parseInt(event.target.value))}\r\n                                        error={orderError}\r\n                                        label={orderError?\"Error\":\"\"}\r\n                                        defaultValue={order.toString()}\r\n                                        helperText={orderErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Typography variant=\"h6\">\r\n                                Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                            </Typography>\r\n                            <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event)=>setSolverType(event.target.value)}>\r\n                                <FormControlLabel value=\"euler\" control={<Radio />} label=\"Euler\" />\r\n                                <FormControlLabel value=\"runge\" control={<Radio />} label=\"Runge-Kutta\" />\r\n                            </RadioGroup>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        {order < 10 && orderArray.map((i) =>\r\n                            <Grid key={\"function\" + i} xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={i===0 ? String.raw`y^{'}, \\frac{dy}{dx}` : String.raw`${ORDER_NAMES[i + 1]}^{'}, \\frac{d${ORDER_NAMES[i + 1]}}{dx}`} />\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={ORDER_FUNCTIONS[i]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(i, mathField.text());\r\n                                                setSpecificFunctionLatex(i, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[i]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[i]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        )}\r\n                    </Grid>\r\n\r\n                    <Grid className=\"initialVector-input\" container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"stepSize-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Step size, h:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setStepSize(parseFloat(event.target.value))}\r\n                                        error={stepSizeError}\r\n                                        label={stepSizeError?\"Error\":\"\"}\r\n                                        defaultValue={stepSize.toString()}\r\n                                        helperText={stepSizeErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item className=\"iteration-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iterations:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setIterations(parseInt(event.target.value))}\r\n                                        error={iterError}\r\n                                        label={iterError?\"Error\":\"\"}\r\n                                        defaultValue={iterations.toString()}\r\n                                        helperText={iterErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params}/>}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        const results = params.results;\r\n        const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n        const newX = results.x[currentIteration - 1];\r\n\r\n        latexContent =\r\n        String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(newX)}\r\n        \\end{array}\r\n        `;\r\n        if (params.solverType === 'runge') {\r\n            // k1\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{1${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k1)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k2\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{1${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{2${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k2)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k3\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{2${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{3${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k3)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k4\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{3${value}}`} (h)`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{4${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k4)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // Find new values\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1${varName}} + 2 k_{2${varName}} + 2 k_{3${varName}} + k_{4${varName}} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + h \\cdot ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult, currentIteration) => {\r\n            for (let i = 0; i < params.iterations; i++){\r\n                const r = params.results['y'][i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${params.initialVector[0]}, ${r.currentValue})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${results.x[i]}, ${r.newValue})` });\r\n            }\r\n            const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n            const newX = results.x[currentIteration - 1];\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newValue})/(x-${newX})=${(currentResult.newValue - currentResult.currentValue)/(newX - currentX)} \\left\\{${currentX}<x<${newX}\\right\\} \\left\\{${currentResult.currentValue}<y<${currentResult.newValue}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentX}, ${currentResult.currentValue})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${newX}, ${currentResult.newValue})` });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n    \r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen?\"column\":\"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen?null:\"20rem\"} width={smallScreen?\"70vw\":null}>\r\n                                <Slider\r\n                                    orientation={smallScreen?\"horizontal\":\"vertical\"}\r\n                                    onChange={(event, value) => {setCurrentIteration(value)}}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{currentIteration, graphCallback, smallScreen, ...params, results: params.results['y']}} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeSystem;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js",["261"],"C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js",["262","263","264","265","266","267","268","269"],"import {isValidMath, formatLatex, mathjsKeywords} from \"../../utils\";\r\nimport {initialMatrix22 as initialMatrix, generateGridCallback, gridTo2DArray, matrixToLatex} from \"../../matrix_utils\";\r\nimport React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, inv, multiply } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps} from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst FUNCTIONS = ['0', '-4','0'];\r\nconst FUNCTIONS_TEXT = ['0', '-4','0'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n        \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of a, b, f(a) and f(b).\",\r\n    },\r\n    {\r\n        target: \".points-input\",\r\n        title: \"Number of points\",\r\n        content:\r\n            \"Specify the number of points in between the lower and upper boundaries.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.primary,\r\n    margin: theme.spacing(1),\r\n  },\r\n  container: {\r\n    \"& > *\": {\r\n        margin: theme.spacing(1)\r\n    }\r\n  },\r\n  card: {\r\n    margin: theme.spacing(0.5),\r\n  },\r\n  cardContent: {\r\n    overflow: 'auto',\r\n    \"& > *\": {\r\n        margin: theme.spacing(0.5)\r\n    }\r\n  },\r\n  fab: {\r\n    position: 'fixed',\r\n    bottom: theme.spacing(4),\r\n    right: theme.spacing(2),\r\n  },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeFiniteDiff({methodName}) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatexs, setFunctionLatexs] = useState(FUNCTIONS);\r\n    const [functionTexts, setFunctionTexts] = useState(FUNCTIONS_TEXT);\r\n\r\n    const functionLatexsRef= useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef= useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = Array(3).fill(false);\r\n    let functionErrorTexts = Array(3).fill(\"\");\r\n\r\n    for (let i = 0; i < 3; i++){\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (node.name !== 'x') {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        catch(e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? \"Only x variable is allowed.\" :  \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    const [lowerX, upperX] = [initialVector[0], initialVector[2]]; \r\n    let intervalError = false;\r\n    let intervalErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        intervalErrorText = \"a must be lower than b!\";\r\n    }\r\n\r\n    // Points\r\n    const [points, setPoints] = useState(9);\r\n    let pointsError = false;\r\n    let pointsErrorText = \"\";\r\n    if (!Number.isInteger(points) || points <= 0) {\r\n        pointsError = true;\r\n        pointsErrorText = \"Number of points must be a positive integer!\";\r\n    }\r\n    const iterations = points + 1;\r\n\r\n    const functionsError = !functionErrors.every((e) => e === false);\r\n    let hasError = functionsError || intervalError || pointsError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let stepSize, xArray;\r\n    let resultsMatrix = [];\r\n    let resultsColumn = [];\r\n    let resultsInverse, resultsSolved;\r\n    let results = [];\r\n    let latexContent, graphCallback;\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        stepSize = (upperX - lowerX) / iterations;\r\n        xArray = [...Array(iterations).keys()].map((i) => stepSize * (i + 1));\r\n        for (let iter = 1; iter < iterations; iter++) {\r\n            const currentX = xArray[iter - 1];\r\n            const pResult = functionNodes[0].evaluate({x: currentX});\r\n            const qResult = functionNodes[1].evaluate({x: currentX});\r\n            const fResult = functionNodes[2].evaluate({x: currentX});\r\n\r\n            const previousYCoeff = (1 - stepSize / 2 * pResult);\r\n            const currentYCoeff = Math.pow(stepSize, 2) * qResult - 2;\r\n            const nextYCoeff = (1 + stepSize / 2 * pResult);\r\n            const row = Array(iterations - 1).fill(0);\r\n            row[iter - 1] = currentYCoeff;\r\n\r\n            let additionalConstant = 0;\r\n            if (iter === 1) {\r\n                additionalConstant = previousYCoeff * initialVector[1];\r\n            }\r\n            else {\r\n                row[iter - 2] = previousYCoeff;\r\n            }\r\n            if (iter === iterations - 1) {\r\n                additionalConstant = nextYCoeff * initialVector[3];\r\n            }\r\n            else {\r\n                row[iter] = nextYCoeff;\r\n            }\r\n            resultsMatrix.push(row);\r\n            resultsColumn.push(Math.pow(stepSize, 2) * fResult - additionalConstant)\r\n        }\r\n        resultsInverse = inv(resultsMatrix);\r\n        resultsSolved = multiply(resultsInverse, resultsColumn);\r\n\r\n        for (let i = 0; i < iterations; i++) {\r\n            results.push({\r\n                currentX: (i === 0) ? initialVector[0] : xArray[i - 1],\r\n                newX: xArray[i],\r\n                currentY: (i === 0) ? initialVector[1] : resultsSolved[i - 1],\r\n                newY: (i === iterations - 1) ? initialVector[3] : resultsSolved[i]\r\n            });\r\n        }\r\n        let yColumnLatex = String.raw`\\left[\\begin{matrix} `;\r\n        for (let i = 1 ; i < iterations; i++) {\r\n            yColumnLatex += String.raw` y_{${i}}\\cr `;\r\n        }\r\n        yColumnLatex += String.raw` \\end{matrix}\\right] `;\r\n\r\n        const limit = 30;\r\n        const tooManyLatex = String.raw`\\left[\\begin{matrix}\r\n               & \\dots  &        \\cr\r\n        \\vdots & \\ddots & \\vdots \\cr\r\n               & \\dots  &        \\cr\r\n        \\end{matrix}\\right]`;\r\n        const tooManyColumnLatex = String.raw`\\left[\\begin{matrix}\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\end{matrix}\\right]`;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& ${formatLatex(stepSize)}\r\n        \\\\ y_{0} &=& ${initialVector[1]}\r\n        \\\\ y_{${iterations}} &=& ${initialVector[3]}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\\\ \\text{From the equation } (1 + \\frac{h}{2} P_i) y_{i+1} + (h^{2} Q_{i} - 2) + (1 - \\frac{h}{2} P_i) y_{i-1} = h^{2} f_{i} \\text{ ,}\r\n        \\\\ \\begin{array}{rcl}\r\n        \\\\ ${ iterations > limit ? tooManyLatex : matrixToLatex(resultsMatrix)} ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, {single: true})}\r\n        \\\\\r\n        \\\\                                 ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, {single: true})} ${iterations > limit ? \"\": matrixToLatex(resultsInverse)}\r\n        \\\\\r\n        \\\\                                 ${yColumnLatex} &=& ${matrixToLatex(resultsSolved, {single: true})}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < iterations; i++){\r\n                const r = results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({ id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                    `(${r.currentX}, ${r.currentY})` });\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                `(${r.newX}, ${r.newY})` });\r\n            }\r\n            calculator.current.setExpression({ id: 'line', color: Desmos.Colors.GREEN, latex:\r\n            String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY)/(currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}` });\r\n            calculator.current.setExpression({ id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel:true, latex:\r\n                `(${currentResult.currentX}, ${currentResult.currentY})` });\r\n            calculator.current.setExpression({ id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel:true, latex:\r\n                `(${currentResult.newX}, ${currentResult.newY})` });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = {iterations, results, smallScreen};\r\n    \r\n    return (\r\n        <>\r\n            <Header methodName = {methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                <Zoom duration={500} triggerOnce cascade>\r\n                    <Typography variant=\"body1\">\r\n                        This method is applied in the form of &nbsp;\r\n                        <TeX math={String.raw`y^{''} + P(x)y^{'} + Q(x)y = f(x)`} />.\r\n                    </Typography>\r\n                    <Divider />\r\n                    <Grid xs item className=\"functions-display\">\r\n                        <Box border={1} borderRadius={5} boxShadow={2}>\r\n                            <Collapse in={!hasError}>\r\n                                {!functionsError && <Fade triggerOnce>\r\n                                <TeX math={String.raw`y^{''} + (${functionLatexs[0]}) y^{'} + (${functionLatexs[1]}) y = ${functionLatexs[2]}`} block />\r\n                                </Fade>}\r\n                            </Collapse>\r\n                        </Box>\r\n                    </Grid>\r\n                    <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`P(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[0]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(0, mathField.text());\r\n                                            setSpecificFunctionLatex(0, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[0]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[0]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`Q(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[1]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(1, mathField.text());\r\n                                            setSpecificFunctionLatex(1, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[1]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[1]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                        <Grid xs item>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        <TeX math={String.raw`F(x)`} />:\r\n                                    </Typography>\r\n                                    <EditableMathField\r\n                                        disabled={false}\r\n                                        latex={FUNCTIONS[2]}\r\n                                        onChange={(mathField) => {\r\n                                            setSpecificFunctionText(2, mathField.text());\r\n                                            setSpecificFunctionLatex(2, mathField.latex());\r\n                                        }}\r\n                                        mathquillDidMount={(mathField) => {\r\n                                        }}\r\n                                    />\r\n                                    <Collapse in={functionErrors[2]}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorTexts[2]}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                    <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Typography variant=\"h6\">\r\n                                    Initial Values:\r\n                                </Typography>\r\n                                <Collapse in={intervalError}>\r\n                                    <Alert severity=\"error\">\r\n                                        {intervalErrorText}\r\n                                    </Alert>\r\n                                </Collapse>\r\n                            </Grid>\r\n                            <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid key={1} item className={styleClasses.overflow}>\r\n                                    <ReactDataGrid\r\n                                        columns={vectorState.columns}\r\n                                        rowGetter={i => vectorState.rows[i]}\r\n                                        rowsCount={vectorState.rows.length}\r\n                                        onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                        enableCellSelect={true}\r\n                                        minColumnWidth={columnWidth}\r\n                                        minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                        rowHeight={rowHeight}\r\n                                        minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                    />\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"points-input\">\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Number of Points between Boundaries:\r\n                                    </Typography>\r\n                                    <TextField\r\n                                        disabled={false}\r\n                                        type=\"number\"\r\n                                        onChange={(event)=>setPoints(parseInt(event.target.value))}\r\n                                        error={pointsError}\r\n                                        label={pointsError?\"Error\":\"\"}\r\n                                        defaultValue={points.toString()}\r\n                                        helperText={pointsErrorText}\r\n                                        variant=\"outlined\"\r\n                                    />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n            \r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && \r\n                            <Container className={styleClasses.container}>\r\n                                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"graph-button\">\r\n                                        <Slide direction=\"right\" triggerOnce>\r\n                                            <Graph params={{currentIteration : 1, graphCallback, smallScreen, ...params}} />\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"step-math\">\r\n                                            <Zoom duration={500} triggerOnce>\r\n                                                <Card className={styleClasses.card}>\r\n                                                    <CardContent className={styleClasses.cardContent}>\r\n                                                        <TeX math={latexContent} block />\r\n                                                    </CardContent>\r\n                                                </Card>\r\n                                            </Zoom>\r\n                                        </Grid>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep \r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                    locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({params}) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    const initialVector = params.initialVector;\r\n    const xArray = params.xArray;\r\n    const currentX = (currentIteration === 1) ? initialVector[0] : xArray[currentIteration - 2];\r\n    const newX = xArray[currentIteration - 1];\r\n\r\n}\r\n\r\nexport default OdeFiniteDiff;","C:\\Users\\ACER NITRO5\\Desktop\\numerical-methods-js\\src\\components\\MethodInfo.js",[],{"ruleId":"270","severity":1,"message":"271","line":1,"column":8,"nodeType":"272","messageId":"273","endLine":1,"endColumn":12},{"ruleId":"274","replacedBy":"275"},{"ruleId":"276","replacedBy":"277"},{"ruleId":"274","replacedBy":"278"},{"ruleId":"276","replacedBy":"279"},{"ruleId":"274","replacedBy":"280"},{"ruleId":"276","replacedBy":"281"},{"ruleId":"270","severity":1,"message":"282","line":1,"column":8,"nodeType":"272","messageId":"273","endLine":1,"endColumn":14},{"ruleId":"274","replacedBy":"283"},{"ruleId":"276","replacedBy":"284"},{"ruleId":"285","severity":1,"message":"286","line":139,"column":21,"nodeType":"287","messageId":"288","endLine":139,"endColumn":42},{"ruleId":"274","replacedBy":"289"},{"ruleId":"276","replacedBy":"290"},{"ruleId":"285","severity":1,"message":"286","line":136,"column":21,"nodeType":"287","messageId":"288","endLine":136,"endColumn":42},{"ruleId":"270","severity":1,"message":"291","line":1,"column":9,"nodeType":"272","messageId":"273","endLine":1,"endColumn":26},{"ruleId":"285","severity":1,"message":"286","line":130,"column":21,"nodeType":"287","messageId":"288","endLine":130,"endColumn":42},{"ruleId":"274","replacedBy":"292"},{"ruleId":"276","replacedBy":"293"},{"ruleId":"285","severity":1,"message":"286","line":129,"column":21,"nodeType":"287","messageId":"288","endLine":129,"endColumn":42},{"ruleId":"274","replacedBy":"294"},{"ruleId":"276","replacedBy":"295"},{"ruleId":"285","severity":1,"message":"286","line":112,"column":21,"nodeType":"287","messageId":"288","endLine":112,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":118,"column":21,"nodeType":"287","messageId":"288","endLine":118,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":116,"column":21,"nodeType":"287","messageId":"288","endLine":116,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":116,"column":21,"nodeType":"287","messageId":"288","endLine":116,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":116,"column":21,"nodeType":"287","messageId":"288","endLine":116,"endColumn":42},{"ruleId":"274","replacedBy":"296"},{"ruleId":"276","replacedBy":"297"},{"ruleId":"285","severity":1,"message":"286","line":117,"column":21,"nodeType":"287","messageId":"288","endLine":117,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":139,"column":21,"nodeType":"287","messageId":"288","endLine":139,"endColumn":42},{"ruleId":"274","replacedBy":"298"},{"ruleId":"276","replacedBy":"299"},{"ruleId":"285","severity":1,"message":"286","line":129,"column":21,"nodeType":"287","messageId":"288","endLine":129,"endColumn":42},{"ruleId":"270","severity":1,"message":"300","line":82,"column":11,"nodeType":"272","messageId":"273","endLine":82,"endColumn":22},{"ruleId":"285","severity":1,"message":"286","line":118,"column":21,"nodeType":"287","messageId":"288","endLine":118,"endColumn":42},{"ruleId":"270","severity":1,"message":"301","line":6,"column":31,"nodeType":"272","messageId":"273","endLine":6,"endColumn":39},{"ruleId":"285","severity":1,"message":"286","line":118,"column":21,"nodeType":"287","messageId":"288","endLine":118,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":133,"column":21,"nodeType":"287","messageId":"288","endLine":133,"endColumn":42},{"ruleId":"302","severity":1,"message":"303","line":238,"column":57,"nodeType":"304","messageId":"305","endLine":238,"endColumn":83},{"ruleId":"302","severity":1,"message":"306","line":242,"column":53,"nodeType":"304","messageId":"305","endLine":242,"endColumn":79},{"ruleId":"274","replacedBy":"307"},{"ruleId":"276","replacedBy":"308"},{"ruleId":"285","severity":1,"message":"286","line":125,"column":21,"nodeType":"287","messageId":"288","endLine":125,"endColumn":42},{"ruleId":"309","severity":1,"message":"310","line":77,"column":8,"nodeType":"311","endLine":77,"endColumn":10,"suggestions":"312"},{"ruleId":"270","severity":1,"message":"300","line":82,"column":11,"nodeType":"272","messageId":"273","endLine":82,"endColumn":22},{"ruleId":"285","severity":1,"message":"286","line":135,"column":21,"nodeType":"287","messageId":"288","endLine":135,"endColumn":42},{"ruleId":"285","severity":1,"message":"286","line":192,"column":25,"nodeType":"287","messageId":"288","endLine":192,"endColumn":46},{"ruleId":"285","severity":1,"message":"286","line":157,"column":25,"nodeType":"287","messageId":"288","endLine":157,"endColumn":46},{"ruleId":"285","severity":1,"message":"286","line":138,"column":25,"nodeType":"287","messageId":"288","endLine":138,"endColumn":46},{"ruleId":"270","severity":1,"message":"313","line":497,"column":10,"nodeType":"272","messageId":"273","endLine":497,"endColumn":15},{"ruleId":"270","severity":1,"message":"314","line":499,"column":11,"nodeType":"272","messageId":"273","endLine":499,"endColumn":23},{"ruleId":"270","severity":1,"message":"315","line":501,"column":30,"nodeType":"272","messageId":"273","endLine":501,"endColumn":49},{"ruleId":"270","severity":1,"message":"316","line":503,"column":9,"nodeType":"272","messageId":"273","endLine":503,"endColumn":17},{"ruleId":"270","severity":1,"message":"317","line":504,"column":9,"nodeType":"272","messageId":"273","endLine":504,"endColumn":18},{"ruleId":"270","severity":1,"message":"318","line":508,"column":11,"nodeType":"272","messageId":"273","endLine":508,"endColumn":19},{"ruleId":"270","severity":1,"message":"319","line":509,"column":11,"nodeType":"272","messageId":"273","endLine":509,"endColumn":15},"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","no-native-reassign",["320"],"no-negated-in-lhs",["321"],["320"],["321"],["320"],["321"],"'styles' is defined but never used.",["320"],["321"],"no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object",["320"],["321"],"'formatMatrixLatex' is defined but never used.",["320"],["321"],["320"],["321"],["320"],["321"],["320"],["321"],"'smallScreen' is assigned a value but never used.","'identity' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'modifiedMatrix'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'modifiedOutput'.",["320"],["321"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'props.smallScreen' and 'updateGraph'. Either include them or remove the dependency array.","ArrayExpression",["322"],"'Steps' is defined but never used.","'styleClasses' is assigned a value but never used.","'setCurrentIteration' is assigned a value but never used.","'hasError' is assigned a value but never used.","'errorText' is assigned a value but never used.","'currentX' is assigned a value but never used.","'newX' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"323","fix":"324"},"Update the dependencies array to be: [props.smallScreen, updateGraph]",{"range":"325","text":"326"},[2998,3000],"[props.smallScreen, updateGraph]"]